

#### 常见的数据结构及其算法java实现

##### 1.冒泡排序

冒泡排序的主要思想：从元素array[i]（0<i<array.length-1）开始，依次和它相邻的元素array[i+1]进行比较，如果发现array[i]>array[i+1]则进行交换，每一趟冒泡排序都把最大（或者最小）元素排到底部，每一趟进行排序的元素个数为array.length-i-1.

**冒泡排序java实现：**

```
public class SortExample {
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();//数组长度
        int[] array = new int[n];
        System.out.println("***原未排序序列***");
        for (int i=0;i<n;i++){
            array[i] = sc.nextInt();
        }
        bubbleSort(array);
        System.out.println("***冒泡排序结果***");
        for(int i=0;i<array.length;i++){
            System.out.print(array[i]+" ");
        }
    }

    /**
     * 冒泡排序
     * @param array
     */
    public static void bubbleSort(int[] array){
        int tmp = 0;
        for(int i = 0;i<array.length-1;i++){
            for(int j=0;j<array.length-i-1;j++){
                if(array[j]>array[j+1]){
                    tmp = array[j];
                    array[j] = array[j+1];
                    array[j+1] = tmp;
                }
            }
        }
    }
}
```

**运行结果：**

```
10
***原未排序序列***
12 1 43 55 21 17 18 19 60 90
***冒泡排序结果***
1 12 17 18 19 21 43 55 60 90 
```

##### 2.快速排序

快速排序的主要思想：快速排序是冒泡排序的一种改进；快速排序设一个轴（一般为排序序列的首元素,即下标为k），然后设排序序列的第一个元素和最后一个元素的下标为low和high,然后首先从high开始往前遍历直至找到比array[k]小的元素，然后与之交换，high--；然后从low开始往后遍历直至找到比array[k]大的元素，然后与之交换，low++；直至low==high时一趟快排结束，这时候array[k]左边的元素均比他小，右边的元素均比他大，然后再递归，分别对左边和右边的元素进行快速排序直至得到有序序列；

**快速排序java实现：**

```
public class SortExample {
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();//数组长度
        int[] array = new int[n];
        System.out.println("***原未排序序列***");
        for (int i=0;i<n;i++){
            array[i] = sc.nextInt();
        }
        rapidSort(array,0,array.length-1);
        System.out.println("***快速排序结果***");
        for (int i=0;i<array.length;i++){
            System.out.print(array[i] + " ");
        }
    }

    /**
     * 快速排序
     */
    public static void rapidSort(int[] array,int low,int high){
        if(low >high){
            return;
        }
        int i = low;
        int j = high;
        int k = array[i];
        boolean flag = true;
        while(i != j){
            if(flag){
                if(k>array[j]){
                    swap(array,i,j);
                    flag = false;
                }else{
                    j --;
                }
            }else{
                if (k < array[i]){
                    swap(array,i,j);
                    flag = true;
                }else{
                    i ++;
                }
            }
        }
        rapidSort(array,low,i-1);
        rapidSort(array,j+1,high);
    }
    //交换数组中的两个元素
    public static void swap(int[] array,int i,int j){
        int tmp =0;
        tmp = array[i];
        array[i] = array[j];
        array[j] = tmp;
    }
}
```

**运行结果：**

```
10
***原未排序序列***
12 1 43 55 21 17 18 19 60 90
***快速排序结果***
1 12 17 18 19 21 43 55 60 90 
```

##### 3.选择排序

**选择排序的基本思想是：每一趟在n-i+1(i=1,2,...,n-1)个记录中选取关键字最小的记录作为有序序列中的第i个记录；**

###### 3.1 简单选择排序

简单选择排序的基本思想：一趟简单选择排序的操作为：通过n-i次关键词间的比较，从n-i+1个记录中选出关键词最小的记录，并和第i（i>=1&&i<=n）个记录交换；

**简单选择排序实现：**

```
public class SortSelect {
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] array = new int[n];
        System.out.println("***排序前序列***");
        for(int i=0;i<array.length;i++){
            array[i] = sc.nextInt();
        }
        selectSort(array);
        ArrayList<Integer> list = new ArrayList<Integer>();
        System.out.println("***简单选择排序后***");
        for(int i : array){
            list.add(i);
        }
        System.out.println(list);
    }

    public static void selectSort(int[] array){
        int tmp = 0;
        int i,j,k;
        for(i=0;i<array.length;i++){
            k = i;
            for(j=i+1;j<array.length;j++){
                if (array[k]>array[j]){
                    k = j;
                }
            }
            tmp = array[k];
            array[k] = array[i];
            array[i] = tmp;
        }
    }
}
```

**运行结果：**
```
10
***排序前序列***
1 2 3 4 21 222 32 888 221 12
***简单选择排序后***
[1, 2, 3, 4, 12, 21, 32, 221, 222, 888]
```
###### 3.2 堆排序

堆的定义如下：n个元素的序列{k1,k2,...,kn},当且仅当满足以下关系时称之为堆：Ki<=K2i&&Ki<=K2i+1或者>=;若将和此序列对应的一维数组（即以一维数组作此序列的存储结构）看成是一个完全二叉树，则堆的定义表明，完全二叉树中所有非终端结点的值均不大于（或不小于）其左右孩子结点的值；堆顶元素必定为序列中n个元素中最大（或者最小）的元素；

**堆排序：若在输出堆顶元素的最小值之后，使得剩余n-1个元素的序列重又建成一个堆，则得到n个元素中的次小值。如此反复执行，便能得到一个有序序列，这个过程称之为堆排序；**

**堆排序实现：**

```
import java.util.Scanner;

/**
 * @ Author: Chong Qin.
 * @ Date: Created in 2018/4/14,19:24
 * @ Description:
 */
public class SortHeap {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] array = new int[n];
        System.out.println("***排序前***");
        for (int i = 0; i < array.length; i++) {
            array[i]=sc.nextInt();
        }
        minHeapSort(array);
        System.out.println("");
        System.out.println("***排序后***");
        for (int i = 0; i < array.length; i++) {
            System.out.print(array[i] + " ");
        }
    }

    public static void minHeapSort(int[] array) {
        if (array == null || array.length == 1)
            return;
        buildMaxHeap(array);
        for (int i = array.length - 1; i >= 1; i--) {
            swap(array, 0, i);
            maxHeap(array, 0, i);
        }
    }

    /**
     * 构建堆
     *
     * @param array
     */
    public static void buildMaxHeap(int[] array) {
        if (array == null || array.length == 1) {
            return;
        }
        int cursor = array.length / 2;
        for (int i = cursor; i >= 0; i--) {
            maxHeap(array, i, array.length);
        }
    }

    /**
     * 大根堆
     *
     * @param array：待构建大根堆数组
     * @param rootIndex：根节点序号
     * @param length:数组长度
     */
    public static void maxHeap(int[] array, int rootIndex, int length) {
        //左子结点
        int left = rootIndex * 2 + 1;
        //右子结点
        int right = rootIndex * 2 + 2;
        //先设定根结点为最大值的结点
        int maxIndex = rootIndex;
        //如果存在左子结点且左子结点的值比根结点的值大，则将左子结点的index赋给maxIndex
        if (left < length && array[left] > array[maxIndex]) {
            maxIndex = left;
        }
        //如果存在右子结点且右子结点的值比根结点的值大，则将右子结点的index赋给maxIndex
        if (right < length && array[right] > array[maxIndex]) {
            maxIndex = right;
        }
        //如果不相等则说明子节点的值有比自己大的
        if (maxIndex != rootIndex) {
            swap(array, maxIndex, rootIndex);
            //交换完之后再递归检查看是否还有子结点的值比自己大，直到构建成大根堆
            maxHeap(array, maxIndex, length);
        }
    }

    /**
     * 小根堆
     *
     * @param array
     * @param rootIndex
     * @param length
     */
    public static void minHeap(int[] array, int rootIndex, int length) {
        int left = rootIndex * 2 + 1;
        int right = rootIndex * 2 + 2;
        int minIndex = rootIndex;
        if (left < length && array[left] < array[minIndex]) {
            minIndex = left;
        }
        if (right < length && array[right] < array[minIndex]) {
            minIndex = right;
        }
        if (rootIndex != minIndex) {
            swap(array, rootIndex, minIndex);
            minHeap(array, minIndex, length);
        }
    }

    /**
     * 交换数组元素
     *
     * @param array
     * @param i
     * @param j
     */
    public static void swap(int[] array, int i, int j) {
        int temp;
        temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
}
```

**运行结果：**

```
10
***排序前***
1 2 6 77 777 12 13 652 6666 7

***排序后***
1 2 6 7 12 13 77 652 777 6666 
```

##### 4.直接插入排序
##### 5.基数排序
##### 6.归并排序

##### 7.图的遍历

###### 7.1 图的分类
**无向图：即两个顶点之间没有明确的指向关系，只有一条边相连，例如，A顶点和B顶点之间可以表示为 <A, B> 也可以表示为<B, A>，如下所示：**

![](https://img-blog.csdn.net/20160525140550262?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

**有向图： 顶点之间是有方向性的，例如A和B顶点之间，A指向了B，B也指向了A，两者是不同的，如果给边赋予权重，那么这种异同便更加显著了；如下图**

![](https://img-blog.csdn.net/20160525140917689?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

在此基础上根据图的连通关系可以分为：
- 无向完全图：在无向图的基础上，每两个顶点之间都存在一条边，一个包含N个顶点的无向完全图，其总边数为N（N-1）/2
- 有向完全图：在有向图的基础上，每两个顶点之间都存在一条边，一个包含N个顶点的有向完全图，其总边数为N（N-1）
- 连通图：针对无向图而言的，如果任意两个顶点之间是连通的，则该无向图称为连通图；
- 非连通图：无向图中，存在两个顶点之间是不连通的，则该无向图称为非连通图；
- 强连通图：针对有向图而言的，如果有向图中任意两个顶点之间是连通的（注意方向问题，A—>B，成立，但B—>A不一定成立），则该有向图称为强连通图；
- 非强连通图：如果有向图中存在两个顶点之间是不连通的，则该有向图称为非强连通图；

###### 7.2 图的存储结构

**1.邻接矩阵：使用二维数组来存储图的边的信息和权重，如下图所示的4个顶点的无向图**

![](https://img-blog.csdn.net/20160525143156203?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

 从上面可以看出，无向图的边数组是一个对称矩阵。所谓对称矩阵就是n阶矩阵的元满足aij = aji。即从矩阵的左上角到右下角的主对角线为轴，右上角的元和左下角相对应的元全都是相等的。

如果换成有向图，则如图所示的五个顶点的有向图的邻接矩阵表示如下:
![](https://img-blog.csdn.net/20160525143355408?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

**邻接矩阵无向图实现：**

```
/**
 * @ Author: Chong Qin.
 * @ Date: Created in 2018/4/16,19:31
 * @ Description:邻接矩阵无向图（matrix No Direction Graph）
 */
public class MatrixNDG {

    int size; //图顶点个数
    char[] vertexs; //图顶点名称
    int[][] matrix; //图关系矩阵

    public MatrixNDG(char[] vertexs,char[][] edges){
        size=vertexs.length;
        matrix = new int[size][size];//设定图关系矩阵大小
        this.vertexs = vertexs;

        //设置矩阵值
        for (char[] c : edges){
            int p1 = getPosition(c[0]);
            int p2 = getPosition(c[1]);

            matrix[p1][p2] =1;
            matrix[p2][p1] =1;
        }
    }

    //图的遍历输出
    private void print(){
        for (int[] i : matrix){
            for (int j : i){
                System.out.print(j + " ");
            }
            System.out.println();
        }
    }

    //根据顶点名称获取对应的矩阵下标
    private int getPosition(char ch) {
        for (int i = 0; i < vertexs.length; i++) {
            if (vertexs[i] == ch)
                    return i;
        }
        return -1;
    }

    public static void main(String[] args){
        char[] vexs = {'A','B','C','D','E','F','G','H','I','J','K'};
        char[][] edges = {{'A','C'},{'A','D'},{'A','F'},{'B','C'},
                {'C','D'},{'E','G'},{'D','G'},{'I','J'},{'J','G'}};
        MatrixNDG pG;
        long start = System.nanoTime();
        pG = new MatrixNDG(vexs,edges);
        pG.print();
        long end = System.nanoTime();

        System.out.println(end-start);
    }
}
```

**邻接矩阵有向图实现：**

```
package com.qc;
/**
 * @ Author: Chong Qin.
 * @ Date: Created in 2018/4/16,19:31
 * @ Description:邻接矩阵无向图（matrix No Direction Graph）
 */
public class MatrixNDG {
    int size; //图顶点个数
    char[] vertexs; //图顶点名称
    int[][] matrix; //图关系矩阵

    public MatrixNDG(char[] vertexs, char[][] edges) {
        size = vertexs.length;
        matrix = new int[size][size];//设定图关系矩阵大小
        this.vertexs = vertexs;
        //设置矩阵值
        for (char[] c : edges) {
            int p1 = getPosition(c[0]);
            int p2 = getPosition(c[1]);
            matrix[p1][p2] = 1;//和无向图实现的唯一区别
        }
    }

    //图的遍历输出
    private void print() {
        for (int[] i : matrix) {
            for (int j : i) {
                System.out.print(j + " ");
            }
            System.out.println();
        }
    }

    //根据顶点名称获取对应的矩阵下标
    private int getPosition(char ch) {
        for (int i = 0; i < vertexs.length; i++) {
            if (vertexs[i] == ch)
                return i;
        }
        return -1;
    }
    public static void main(String[] args) {
        char[] vexs = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K'};
        char[][] edges = new char[][]{{'A', 'C'}, {'A', 'D'}, {'A', 'F'}, {'B', 'C'},
                {'C', 'D'}, {'E', 'G'}, {'D', 'G'}, {'I', 'J'}, {'J', 'G'}};
        MatrixNDG pG;
        long start = System.nanoTime();
        pG = new MatrixNDG(vexs, edges);
        pG.print();
        long end = System.nanoTime();
        System.out.println(end - start);
    }
}
```
**2.邻接表：邻接矩阵是一种不错的图存储结构，但是对于边数相对较少的图，这种结构存在空间上的极大浪费，因此找到一种数组与链表相结合的存储方法称为邻接表。**

邻接表的处理方法是这样的：
（1）图中顶点用一个一维数组存储，当然顶点也可以用单链表来存储，不过数组可以比较容易的读取顶点的信息，更加方便；
（2）**图中每个顶点vi的所有邻接点构成一个线性表**，由于邻接点的个数不定，所以使用单链表存储，无向图称为顶点vi的边表，有向图则称为顶点vi作为弧尾的出边表

以下为无向图的邻接表表示：

![](https://img-blog.csdn.net/20160525144354062?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

从图中可以看出，顶点表的各个节点由data和firstedge两个域表示，data是数据域，存储顶点的信息，firstedge是指针域，指向此顶点的第一个邻接点。邻接点由adjvex和next两个域组成。adjvex是邻接点域，存储此邻接点在顶点表中的下标，next则存储指向边表中下一个结点的指针；

以下为有向图的邻接表表示：

![](https://img-blog.csdn.net/20160525144417529?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

**邻接表实现图代码**
**1.顶点结构定义**

```
package com.qc;

/**
 * @ Author: Chong Qin.
 * @ Date: Created in 2018/4/17,19:53
 * @ Description:VertextNode(顶点类)
 */
public class VertexNode {

    private String data; //顶点域
    EdgeNode firstEdge; //此顶点指向的第一个邻接点
    private int id;

    public String getData() {
        return data;
    }

    public void setData(String data) {
        this.data = data;
    }

    public EdgeNode getFirstEdge() {
        return firstEdge;
    }

    public void setFirstEdge(EdgeNode firstEdge) {
        this.firstEdge = firstEdge;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }
}
```

**2.边表结点定义**
```
package com.qc;

/**
 * @ Author: Chong Qin.
 * @ Date: Created in 2018/4/17,19:55
 * @ Description:边表结点类（邻接点类）
 */
public class EdgeNode {
    private String Adjvex; //邻接点域，存储此邻接点在顶点表中对应下标
    private int weight; //权重
    private EdgeNode next;
    private int edgeInfo; //边值

    public String getAdjvex() {
        return Adjvex;
    }

    public void setAdjvex(String adjvex) {
        Adjvex = adjvex;
    }

    public int getWeight() {
        return weight;
    }

    public void setWeight(int weight) {
        this.weight = weight;
    }

    public EdgeNode getNext() {
        return next;
    }

    public void setNext(EdgeNode next) {
        this.next = next;
    }

    public int getEdgeInfo() {
        return edgeInfo;
    }

    public void setEdgeInfo(int edgeInfo) {
        this.edgeInfo = edgeInfo;
    }
}
```

**3.图结构实现**

```
package com.qc;

/**
 * @ Author: Chong Qin.
 * @ Date: Created in 2018/4/17,20:05
 * @ Description:图的实现
 */
public class GraphLink {
    private int numInputV, numInputE; //输入的总数
    VertexNode[] vertexNode;
    Boolean kind = false; //是否为有向图

    public GraphLink(int sizeVertexes, Boolean kind) {
        if (sizeVertexes > 0 && sizeVertexes < 65535) {
            vertexNode = new VertexNode[sizeVertexes]; //初始化顶点域
            numInputE = 0;
            numInputV = 0;
            for (int i = 0; i < vertexNode.length; i++) {
                vertexNode[i] = null;
            }
        } else {
            new RuntimeException("创建失败！");
        }
        this.kind = kind;
    }

    //输入头节点
    public void InsertVertexes(String ev) {
        VertexNode vt = new VertexNode();
        vt.setData(ev);
        vt.setFirstEdge(null);
        vt.setId(numInputV);

        vertexNode[numInputV] = vt;
        numInputV++;
    }

    /**
     * 建立边表，头插法，把边的next指向顶点的firstEdge,顶点的firstedge
     * 指向EdgeNode的getNext()
     */
    public void InsertEdges(String start, String end, int weight, int ID) {
        int pos = getVertexPos(start);
        if (pos != -1) {
            EdgeNode en = new EdgeNode();
            en.setAdjvex(end);
            en.setEdgeInfo(ID);
            en.setWeight(weight);
            en.setNext(vertexNode[pos].getFirstEdge());
            vertexNode[pos].setFirstEdge(en);
            numInputE++;
        }
        //无向图
        if (!kind) {
            int posEnd = getVertexPos(end);
            if (posEnd != -1) {
                EdgeNode enStart = new EdgeNode();
                enStart.setAdjvex(start);
                enStart.setEdgeInfo(ID);
                enStart.setWeight(weight);
                enStart.setNext(vertexNode[pos].getFirstEdge());
                vertexNode[posEnd].setFirstEdge(enStart);
                numInputE++;
            }
        }
    }

    public int getVertexPos(String vertex) {
        //输出顶点vertex在图中的位置
        for (int i = 0; i < numInputV; i++) {
            if (vertexNode[i].getData() == vertex) {
                return i;
            }
        }
        return -1;
    }

    public String getFirstNeighbor(String vertex) {
        int pos = getVertexPos(vertex);
        if (pos != -1) {
            EdgeNode en = vertexNode[pos].getFirstEdge();
            return en.getAdjvex();
        }
        return null;
    }

    //给出顶点v的邻接点w，求下一个邻接点
    public String getSecondNeighbor(String start, String next) {
        int pos1 = getVertexPos(start);
        int pos2 = getVertexPos(next);

        if (pos1 != -1 && pos2 != -1) {
            EdgeNode en = vertexNode[pos1].getFirstEdge();
            while (en != null && en.getAdjvex() != next) {
                en = en.getNext();
            }
            if (en.getNext() != null) {
                return en.getNext().getAdjvex();
            }
        }
        return null;
    }

    public int getNumInputV() {
        return numInputV;
    }

    public void setNumInputV(int numInputV) {
        this.numInputV = numInputV;
    }

    public int getNumInputE() {
        return numInputE;
    }

    public void setNumInputE(int numInputE) {
        this.numInputE = numInputE;
    }

    public VertexNode[] getVertexNode() {
        return vertexNode;
    }

    public void setVertexNode(VertexNode[] vertexNode) {
        this.vertexNode = vertexNode;
    }
}
```

**4.测试类**

```
package com.qc;

import java.util.LinkedList;
import java.util.Queue;

/**
 * @ Author: Chong Qin.
 * @ Date: Created in 2018/4/17,21:04
 * @ Description:测试类
 */
public class TestGraph {
    public static void main(String[] args) {
        TestGraph tg = new TestGraph();
        tg.initGraph();
    }

    private void initGraph() {

        GraphLink gl = new GraphLink(9, false);

        gl.InsertVertexes("A");
        gl.InsertVertexes("B");
        gl.InsertVertexes("C");
        gl.InsertVertexes("D");
        gl.InsertVertexes("E");
        gl.InsertVertexes("F");
        gl.InsertVertexes("G");
        gl.InsertVertexes("H");
        gl.InsertVertexes("I");

        gl.InsertEdges("A", "B", 0, 1);
        gl.InsertEdges("A", "F", 0, 2);
        gl.InsertEdges("B", "C", 0, 3);
        gl.InsertEdges("B", "I", 0, 4);
        gl.InsertEdges("B", "G", 0, 5);
        gl.InsertEdges("C", "I", 1, 6);
        gl.InsertEdges("C", "D", 1, 7);
        gl.InsertEdges("D", "G", 1, 8);
        gl.InsertEdges("D", "I", 5, 1);
        gl.InsertEdges("D", "H", 4, 2);
        gl.InsertEdges("D", "E", 3, 3);
        gl.InsertEdges("E", "F", 2, 4);
        gl.InsertEdges("E", "H", 1, 5);
        gl.InsertEdges("G", "F", 1, 6);

        System.out.println("****深度优先遍历DFS****");
        DFSTraverse(gl);

        /*System.out.print(gl.getFirstNeighbor("A") + " ");
        System.out.println("");
        System.out.print(gl.getSecondNeighbor("A","F"));*/

    }

    Boolean[] visited;

    private void DFS(GraphLink gl, int i) {

        visited[i] = true;
        System.out.print(gl.vertexNode[i].getData() + " ");
        EdgeNode en = gl.vertexNode[i].getFirstEdge();//获取当前结点的下一个相邻结点
        while (en != null) {

            int pos = gl.getVertexPos(en.getAdjvex());

            if (!visited[pos]) {
                DFS(gl, gl.getVertexPos(en.getAdjvex()));
            }
            en = en.getNext();
        }
    }

    void DFSTraverse(GraphLink gl) {

        visited = new Boolean[gl.getNumInputV()];
        for (int i = 0; i < gl.getNumInputV(); i++) {
            visited[i] = false;
        }
        for (int i = 0; i < gl.getNumInputV(); i++) {
            if (!visited[i]) {
                DFS(gl, i);
            }
        }
    }


    /**
     * 广度优先
     *
     * @param gl
     */
    private void BFSTraverse(GraphLink gl) {
        Queue<String> q = new LinkedList<String>();//初始化一个辅助队列

        Boolean[] visitedB = new Boolean[gl.getNumInputV()];
        for (int i = 0; i < gl.getNumInputV(); i++) {
            visitedB[i] = false;
        }

        //访问i元素
        for (int i = 0; i < gl.getNumInputV(); i++) {

            if (!visitedB[i]) {
                System.out.println(gl.getVertexNode()[i].getData());//getData中为顶点头的内容
                visitedB[i] = true;
                q.add(gl.getVertexNode()[i].getData());//把当前顶点添加到队列中

                while (!q.isEmpty()) {//队列不为空则一直循环
                    int j = gl.getVertexPos(q.poll());//获取当前出栈元素的位置
                    EdgeNode en = gl.getVertexNode()[j].getFirstEdge();//当前出栈元素的连接边
                    while (en != null) {
                        j = gl.getVertexPos(en.getAdjvex());//Agjvex为String，需先获取在图中位置,当前边对应结点在图中的位置（id）
                        if (!visitedB[j]) {
                            visitedB[j] = true;
                            System.out.println(en.getAdjvex());
                            q.add(en.getAdjvex());//将顶点入栈
                        }
                        en = en.getNext();//指向下一个结点
                    }
                }
            }
        }
    }
}
```

**测试用例中图的结构如下：**

![](https://img-blog.csdn.net/20160312213313087)

运行结果如下：

```
****深度优先遍历DFS****
A F G D E H I C B 
Process finished with exit code 0
```

##### 8.树
数据结构，指的是数据的存储结构，常见的有线性结构（数组，链表，队列，栈），还有非线性结构（树，图等）。

###### 8.1 树的定义
线性结构中，一个节点至多只有一个头节点，至多只有一个尾节点，彼此连接起来是一条完整的线；比如链表和数组；

![](https://img-blog.csdn.net/20161111211817802)

而树，非线性结构的典型例子，**不再是一对一，而变成了一对多（图可以是多对多），如下图所示：**

![](https://img-blog.csdn.net/20161111212248502)

从图中可以看出：
- 图中的结构就像一棵倒过来的树，最顶部的节点就是**根节点（root节点）**
- 每棵树至多只有一个根节点
- 根节点生出多个孩子节点，每个孩子节点只有一个父节点，每个孩子节点又生出多个孩子
- 父节点（parent）和孩子节点（child）是相对的
- 没有孩子节点的节点成为叶子节点（leaf）

###### 8.2 树的相关术语
根节点、父亲节点、孩子节点、叶子节点如上所述；
![](https://img-blog.csdn.net/20161112192748032)

- 节点的度：一个节点直接含有的子树个数，叫做节点的度；比如上图中的3的度是2,10的度是1；
- 树的度：一棵树中最大节点的度，即哪个节点的子节点最多，他的度就是树的度，上述树的度为2；
- 节点的层次：从根节点开始算起，根节点算一层，往后递增，比如上图中3的层次是2,4的层次是4；
- 树的高度：树的高度是从叶节点开始，自底向上增加；
- 树的深度：与高度相反，树的深度从根节点开始，自顶向下增加。整个树的高度、深度是一样的，但是中间节点的高度 和 深度是不同的，比如上图中的 6 ，高度是 2 ，深度是 3；

###### 8.3 树的两种实现

从上述概念可知，树是递归的概念，从根节点开始，每个节点至多只有一个父节点，有多个子节点，每个子节点又是一棵树，以此递归；

树有两种实现方式：**数组和链表**

**数组表示：我们可以利用每个节点至多只有一个父节点这个特点，使用父节点表示法来实现一个节点**

```
//树的一个节点的表示
public class TreeNode{
	private Object mData;//存储的数据
	private int mParent;//父亲节点的下标

	public TreeNode(Object data,int parent){
		this.mData = data;
		this.mParent = parent;
	}
	public Object getData(){
		return mData;
	}
	public void setData(Object data){
		this.mData = data;
	}
	public int getParent(){
		return mParent;
	}
	public void setParent(int parent){
		this.mParent = parent;
	}
}
```
**上述代码中使用角标来指明父亲节点的位置，使用这个节点组成的数组就可以表示一棵树**

```
public static void main(String[] args){
	TreeNode[] arrayTree = new TreeNode[10];
}
```

用数组实现的树表示下面的树，（其中一种）结果就是这样的：

![](https://img-blog.csdn.net/20161112192748032)
![](https://img-blog.csdn.net/20161112223704256)

**数组实现的树节点使用角标表示父亲的索引，下面用链表表示一个节点和一棵树**

**链表表示的节点：**

```
//使用链表表示一个节点
public class LinkedTreeNode{
	private Object mData;//存储的数据
	private LinkedTreeNode mParent;//父亲节点的下标
	private List<LinkedTreeNode> mChildNodeList;//孩子节点的引用

	public LinkedTreeNode(Object data,LinkedTreeNode parent){
		this.mData = data;
		this.mParent = parent;
	}
	public Object getData(){
		return mData;
	}
	public void setData(Object data){
		this.mData = data;
	}
	public Object getParent(){
		return mParent;
	}
	public void setParent(LinkedTreeNode parent){
		this.mParent = parent;
	}
	public List<LinkedTreeNode> getChild(){
		return mChildNodeList;
	}
	public void setChild(List<LinkedTreeNOde> childList){
		this.mChildNodeList = childList;
	}
}
```
**使用引用而不是索引表示父亲与孩子节点，使用一个List，元素是LinkedTreeNode就可以表示一棵链表树；**

```
public static void main(String[] args){
	LinkedList<LinkedTreeNode> linkedTree = new LinkedList<>();
}
```

**这样只需知道根节点就可以遍历整个树，知道某个节点也可以获取它的父亲和孩子**

###### 8.4 树的几种常见分类以及使用场景

树，为了更好的查找性能而生；常见的树有以下几种分类：
- 二叉树
- 平衡二叉树
- B树
- B+树
- 哈夫曼树
- 堆
- 红黑树

接下来陆续介绍这几种类别的树；

##### 9.二叉树

###### 9.1 相关概念与定义
**定义：二叉树是有限个节点的集合，这个集合可以是空集，也可以是一个根节点和至多两个子二叉树组成的集合，其中一棵树叫做根的左子树，一棵树叫做根的右子树；简单来说二叉树是每个节点至多有两个子树的树**

满二叉树：一棵树高度为K，且拥有2^k-1个节点，则成为满二叉树；
完全二叉树：1.所有叶子节点都出现在k层或者k-1层，而且从1到k-1层必须达到最大节点数；2.第k层不是满的，但是第k层的所有节点必须集中在最左边。

**满二叉树和完全二叉树对比图：**

![](https://img-blog.csdn.net/20161116232828249)

###### 9.2 二叉树的实现

**用递归节点实现法（左右链表示法）表示一个二叉树节点**

```
public class BinaryTreeNode{
	//一个二叉树包括数据，左右孩子节点三部分
	private int mData;
	private BinaryTreeNode mLeftChild;
	private BinaryTreeNode mRightChild;

	public BinaryTreeNode(int data,BinaryTreeNode leftChild,BinaryTreeNode rightChild){
		this.mData = data;
		this.mLeftChild = leftChild;
		this.mRightChild = rightChild;
	}
	public int getData(){
		return mData;
	}
	public int setData(int data){
		this.mData = data;
	}
	public BinaryTreeNode getLeftChild(){
		return mLeftChild;
	}
	public BinaryTreeNode setLeftChild(BinaryTreeNode leftChild{
		this.mLeftChild = leftChild;
	}
	public BinaryTreeNode getRightChild(){
		return mRightChild;
	}
	public void setRightChild(BinaryTreeNode rightChild){
		this.mRightChild = rightChild;
	}
}
```
用这种实现方式表示的节点创建的树，结构如右图所示：
![](https://img-blog.csdn.net/20161116235611306)

**用数组下标表示法表示一个节点：**

```
//数组实现，保存的不是左右子树的引用，而是数组下标
public class BinaryTreeArrayNode{
	private int mData;
	private int mLeftChild;
	private int mRightChild;

	public int getData() {
        return mData;
    }

    public void setData(int data) {
        mData = data;
    }

    public int getLeftChild() {
        return mLeftChild;
    }

    public void setLeftChild(int leftChild) {
        mLeftChild = leftChild;
    }

    public int getRightChild() {
        return mRightChild;
    }

    public void setRightChild(int rightChild) {
        mRightChild = rightChild;
    }
	
}
```

###### 9.3 二叉树的创建

**创建一个二叉树需要有一个二叉根节点，然后提供设置根节点的方法即可：**

```
public class BinaryTree{
	private BinaryTreeNode mRoot; //根节点

	public BinaryTree(){
	}

	public BinaryTree(BinaryTreeNode root){
		mRoot = rooot;
	}
	public BinaryTreeNode getRoot(){
		return mRoot;
	}
	public void setRoot(BinaryTreeNode root){
		mRoot = root;
	}
}
```

###### 9.4 二叉树的添加元素

**由于二叉树有左右子树之分，所以添加元素时也分为两种情况，添加左子树和右子树**

```
public void insertAsLeftChild(BinaryTreeNode child){
	checkTreeEmpty();
	mRoot.setLeftChild(child);
}

public void insertAsRightChild(BinaryTreeNode child){
	checkTreeEmpty();
	mRoot.setRightChild(child);
}

public void checkEmpty(){
	if(MRoot == null){
		throw new IllegalStateException("Can not insert to a null tree! Did you foget set value for root");
	}
}
```

在每次插入之前都会检查根节点是否为空，如果是就抛出异常；

###### 9.5 二叉树删除元素

删除某个元素很简单，只需要把自己设为null，但是为了避免浪费无用的内存方便GC回收，我们还需要挨个遍历这个元素的左右子树，挨个设为空；

```
public void deleteNode(BinaryTreeNode node){
	checkEmpty();
	if(node == null){
		return;
	}
	deleteNode(node.getLeftNode());
	deleteNode(node.getRightNode());
	node = null;
}
```

###### 9.6 二叉树的清空

**二叉树的清空其实就是特殊的删除元素，删除根节点；**

```
public void clear(){
	if(mRoot != null){
		deleteNode(mRoot);
	}
}
```

###### 9.7 获得二叉树的高度

**二叉树中，树的高度是 各个节点度的最大值。因此获得树的高度需要递归获取所有节点的高度，然后取最大值**

```
/*
* 获得树的高度，特殊的获得节点高度
* @return
*/
public int getTreeHeight(){
	return getHeight(mRoot);
}
/*
* 获得指定节点的度
* @param node
* return
*/
public int getHeight(BinaryTreeNode node){
	if(node == null){
		return;
	}
	int leftChildHeight = getHeight(node.getLeftChild());
	int rightChildHeght = getHeight(node.getRightChild());
	int max = Math.max(leftChildHeight,rightChildHeight);
	return max+1;
}

```

###### 9.7 获得某个节点的父亲节点

由于我们使用左右子树表示的节点，不含有父亲节点引用，因此有时候需要一个方法来返回二叉树中指定节点的父亲节点；需要从顶向下遍历各个子树，若该子树的根节点的孩子就是目标节点，返回该节点，否则递归遍历它的左右子树；

```
/*
* 获得指定节点的父亲节点
* @param node
* @return
*/
public BinaryTreeNode getParent(BinaryTreeNode node){
	if(node == null || mRoot == node){ //如果是空树，或者这个节点就是根节点返回空
	return null;
	}else{
		return getParent(mRoot,node); //否则递归查找父亲节点
	}
}

/**
* 递归对比 节点的孩子节点与指定节点是否一致
* @ param subTree 子二叉树根节点
* @ param node 指定节点
* @ return
*/

public BinaryTreeNode getParent(BinaryTreeNode subTree,BinaryTreeNode node){
	if(subTree == null){  //如果子树为空，则没有父亲节点，递归出口
		return null;
	}
	//正好这个根节点的左右孩子节点之一与目标节点一致
	if(subTree.getLeftChild() == node || subTree.getRightChild() == node){
		return subTree;
	}
	//需要遍历这个节点的左右子树
	BinaryTreeNode parent;
	if((parent = getParent(subTree.getLeftChild(),node)) != null){   //左子树节点就是指定节点，返回
		return parent;
	} else{
		return getParent(subTree.getRightChild(),node); //从右子树找找看
	}
}
```

###### 9.8 二叉树的遍历

**二叉树的递归数据结构使得很多操作都可以使用递归进行，而二叉树的遍历其实也是个递归遍历的过程，使得每个节点被访问且仅访问一次；根据不同的场景中，根节点，左右子树遍历的顺序，二叉树的遍历分为先序遍历、中序遍历和后序遍历。这里先序、中序、后序指的是根节点相对左右子树的遍历顺序**

**先序遍历：即根节点在左右子树之前遍历，先访问根节点，再先序遍历左子树，再先序遍历右子树，退出**

**先序遍历递归实现：**

```
/*
* 先序遍历
* @param node
*/
public void iterateFirstOrder(BinaryTreeNode node){
	if(node == null){
		return;
	}
	opreate(node);
	iterateFirstOrder(node.getLeftChild());
	iterateFirstOrder(node.getRightChild());
}
/*
* 模拟操作
* @param node
*/
public void operate(BinaryTreeNode node){
	if(node == null){
		return;
	}
	System.out.println(node.getData());
}
```

**中序遍历递归实现：先中序遍历左子树，再中序遍历根节点，再中序遍历右子树，退出**

```
/*
* 中序遍历
* @param node
*/
public void iterateMediunOrder(BinaryTreeNode node){
	if(node == null){
		return;
	}
	iterateMediumOrder(node.getLeftChild());
	opreate(node);
	iterateMediumOrder(node.getRightChild());
}
```

**后序遍历递归实现：先后序遍历左子树，再后序遍历右子树，然后后序遍历根节点，退出**

```
public void iterateLastOrder(BinaryTreeNode node){
	if(node == null){
		return;
	}
	iterateLastOrder(node.getLeftChild());
	iterateLastOrder(node.getRightChild());
	opreate(node);
}
```
**二叉树的遍历非递归实现：**

```
package com.whu.qc;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Stack;

/**
 * @ Description:
 * @ Author: Chong Qin.
 * @ Date: Created in 2018/4/19,10:57
 */
public class BiTreeTest {
    public static void main(String[] args) {
        BiTreeTest treeTest = new BiTreeTest();
        int[] datas = {1, 2, 3, 4, 5, 6, 7, 8, 9};
        List<Node> nodeList = new LinkedList<>();
        treeTest.createBinaryTree(datas, nodeList);
        Node root = nodeList.get(0);
        System.out.println("递归先序遍历");
        treeTest.preOrderTraversal(root);
        System.out.println();
        System.out.println("非递归先序遍历");
        treeTest.preOrderTraversalByLoop(root);
        System.out.println();
        System.out.println("递归中序遍历");
        treeTest.inOrderTraversal(root);
        System.out.println();
        System.out.println("非递归中序遍历");
        treeTest.inOrderTraversalByLoop(root);
        System.out.println();
        System.out.println("递归后序遍历");
        treeTest.postOrderTraversal(root);
        System.out.println();
        System.out.println("非递归先序遍历");
        treeTest.postOrderTraversalByLoop(root);
        System.out.println();
        System.out.println("广度优先遍历");
        treeTest.bfs(root);
        System.out.println();
        System.out.println("深度优先遍历");
        List<List<Integer>> rst = new ArrayList<>();
        List<Integer> list = new ArrayList<>();
        treeTest.dfs(root, rst, list);
        System.out.println(rst);
    }
        /**
         * 创建二叉树
         *
         * @param datas    实现二叉树各节点值的数组
         * @param nodeList 二叉树list
         */

    private void createBinaryTree(int[] datas, List<Node> nodeList) {
        //将数组变成node节点
        for (int nodeindex = 0; nodeindex < datas.length; nodeindex++) {
            Node node = new Node(datas[nodeindex]);
            nodeList.add(node);
        }
        //给所有父节点设定子节点
        for (int index = 0; index < nodeList.size() / 2 - 1; index++) {
            /**
             * 编号为n的节点的左子节点编号为2*n，右子节点编号为2*n+1,list从0开始编号，所以还要+1
             * 这里父节点有1(2,3),2(4,5),3(6,7),4(8,9) 但是最后一个父节点
             * 有可能没有右子节点，所以需要单独讨论
             */
            nodeList.get(index).setLeftChild(nodeList.get(index * 2 + 1));
            nodeList.get(index).setRightChild(nodeList.get(index * 2 + 2));
        }
        // 单独处理最后一个父节点
        int index = nodeList.size() / 2 - 1;
        nodeList.get(index).setLeftChild(nodeList.get(index * 2 + 1)); //先设置左子节点
        if (nodeList.size() % 2 == 1) {
            nodeList.get(index).setRightChild(nodeList.get(index * 2 + 2));
        }
    }

    /**
     * 遍历当前节点的值
     *
     * @param node
     */
    public void checkCurrentNode(Node node) {
        System.out.print(node.getData() + " ");
    }

    /**
     * 递归先序遍历二叉树
     *
     * @param node 二叉树根节点
     */
    public void preOrderTraversal(Node node) {
        if (node == null)
            return;
        checkCurrentNode(node);
        preOrderTraversal(node.getLeftChild());
        preOrderTraversal(node.getRightChild());
    }

    /**
     * 递归中序遍历二叉树
     *
     * @param node 二叉树根节点
     */
    public void inOrderTraversal(Node node) {
        if (node == null)
            return;
        inOrderTraversal(node.getLeftChild());
        checkCurrentNode(node);
        inOrderTraversal(node.getRightChild());
    }

    /**
     * 递归后序遍历二叉树
     *
     * @param node 二叉树根节点
     */
    public void postOrderTraversal(Node node) {
        if (node == null)
            return;
        postOrderTraversal(node.getLeftChild());
        postOrderTraversal(node.getRightChild());
        checkCurrentNode(node);
    }

    /**
     * 非递归前序遍历
     *
     * @param node
     */
    public void preOrderTraversalByLoop(Node node) {
        Stack<Node> stack = new Stack<Node>();
        Node p = node;
        while (p != null || !stack.isEmpty()) {
            //若p不为空就读取p的值并不断更新p为其左子节点，即不断读取左子节点
            while (p != null) {
                checkCurrentNode(p);
                stack.push(p);
                p = p.getLeftChild();
            }
            //当p为空时说明根节点和左孩子打印遍历完毕了，接下来出栈遍历右孩子
            if (!stack.isEmpty()) {
                p = stack.pop();
                p = p.getRightChild();
            }
        }
    }

    /**
     * 中序非递归遍历
     *
     * @param node
     */
    public void inOrderTraversalByLoop(Node node) {
        Stack<Node> stack = new Stack<Node>();
        Node p = node;
        while (p != null || !stack.isEmpty()) {
            while (p != null) {
                stack.push(p);
                p = p.getLeftChild();
            }
            if (!stack.isEmpty()) {
                stack.pop();
                checkCurrentNode(p);
                p = p.getRightChild();
            }
        }
    }

    /**
     * 非递归后序遍历
     *
     * @param node
     */
    public void postOrderTraversalByLoop(Node node) {
        Stack<Node> stack = new Stack<Node>();
        Node p = node, prev = node;
        while (p != null || !stack.isEmpty()) {
            while (p != null) {
                stack.push(p);
                p = p.getLeftChild();
            }
            if (!stack.isEmpty()) {
                //peek()方法查看堆栈顶部的对象但是不移除它
                Node temp = stack.peek().getRightChild();
                if (temp == null || temp == prev) {
                    p = stack.pop();
                    checkCurrentNode(p);
                    prev = p;
                    p = null;
                } else {
                    p = temp;
                }
            }
        }

    }

    /**
     * 广度优先遍历（从上到下遍历二叉树）
     *
     * @param node
     */
    public void bfs(Node node) {
        if (node == null)
            return;
        LinkedList<Node> queue = new LinkedList<Node>();
        queue.offer(node); //首先将根节点存入队列
        /**
         * 当队列里有值时，每次取出队首的node打印，打印之后判断
         * node是否有子节点，若有，则将子节点加入队列
         */
        while (queue.size() > 0) {
            Node p = queue.peek();
            queue.poll();//取出队首元素并打印
            System.out.println(p.data + " ");
            if (p.leftChild != null) { //如果有左子结点，则将其存入队列
                queue.offer(p.leftChild);
            }
            if (p.rightChild != null) { //如果有右子节点，则将其存入队列
                queue.offer(p.rightChild);
            }
        }
    }

    /**
     * 深度优先遍历
     *
     * @param node
     * @param rst
     * @param list
     */
    public void dfs(Node node, List<List<Integer>> rst, List<Integer> list) {
        if (node == null)
            return;
        if (node.leftChild == null && node.rightChild == null) {
            list.add(node.data);
            /* 这里将list存入rst中时，不能直接将list存入，而是通过新建一个list来实现，
             * 因为如果直接用list的话，后面remove的时候也会将其最后一个存的节点删掉*/
            rst.add(new ArrayList<>(list));
            list.remove(list.size() - 1);
        }
        list.add(node.data);
        dfs(node.leftChild, rst, list);
        dfs(node.rightChild, rst, list);
        list.remove(list.size() - 1);
    }
}

/*
* 节点类
* data ：节点值
* leftChild：节点左子节点
* rightChild：节点右子节点
* */
class Node {
    int data;
    Node leftChild;
    Node rightChild;

    public Node(int data) {
        this.data = data;
    }

    public int getData() {
        return data;
    }

    public void setData(int data) {
        this.data = data;
    }

    public Node getLeftChild() {
        return leftChild;
    }

    public void setLeftChild(Node leftChild) {
        this.leftChild = leftChild;
    }

    public Node getRightChild() {
        return rightChild;
    }

    public void setRightChild(Node rightChild) {
        this.rightChild = rightChild;
    }
}
```
##### 10 B、B-、B+、B* Tree

###### 10.1 B树

**B树：即二叉搜索树，1.所有非叶子节点至多拥有两个儿子（Left和Right）；2.所有节点存储一个关键字；3.非叶子节点的左指针指向小于其关键字的子树；**
![](http://p.blog.csdn.net/images/p_blog_csdn_net/manesking/1.JPG)

B树的搜索，从根结点开始，如果查询的关键字与结点的关键字相等，那么就命中；否则，如果查询关键字比结点关键字小，就进入左儿子；如果比结点关键字大，就进入右儿子；如果左儿子或右儿子的指针为空，则报告找不到相应的关键字；
 如果B树的所有非叶子结点的左右子树的结点数目均保持差不多（平衡），那么B树的搜索性能逼近二分查找；但它比连续内存空间的二分查找的优点是，改变B树结构（插入与删除结点）不需要移动大段的内存数据，甚至通常是常数开销；
![](http://p.blog.csdn.net/images/p_blog_csdn_net/manesking/2.JPG)

但是B树在经过多次插入与删除后，有可能导致不同的结构；
![](http://p.blog.csdn.net/images/p_blog_csdn_net/manesking/31.JPG)

右边也是一个B树，但它的搜索性能已经是线性的了；同样的关键字集合有可能导致不同的树结构索引；所以，使用B树还要考虑尽可能让B树保持左图的结构，和避免右图的结构，也就是所谓的“平衡”问题；      
       实际使用的B树都是在原B树的基础上加上平衡算法，即“平衡二叉树”；如何保持B树结点分布均匀的平衡算法是平衡二叉树的关键；平衡算法是一种在B树中插入和删除结点的策略；

###### 10.2 B-树

**是一种多路搜索树（并不是二叉的）**
- 定义任意非叶子结点最多只有M个儿子，且M>2；
- 根结点的儿子数为[2, M]；
- .除根结点以外的非叶子结点的儿子数为[M/2, M]；
- 每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）
- 非叶子结点的关键字个数=指向儿子的指针个数-1；
- 非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]；
- 非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；
- 所有叶子结点位于同一层；
- 如下图：（M=3）

![](http://p.blog.csdn.net/images/p_blog_csdn_net/manesking/4.JPG)

B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点；

B-树的特性：
-  1.关键字集合分布在整颗树中；
- 2.任何一个关键字出现且只出现在一个结点中；
- 3.搜索有可能在非叶子结点结束；
- 4.其搜索性能等价于在关键字全集内做一次二分查找；
- 5.自动层次控制；

由于限制了除根结点以外的非叶子结点，至少含有M/2个儿子，确保了结点的至少利用率，其最底搜索性能为：

![](http://p.blog.csdn.net/images/p_blog_csdn_net/manesking/0.JPG)
 其中，M为设定的非叶子结点最多子树个数，N为关键字总数；
       所以B-树的性能总是等价于二分查找（与M值无关），也就没有B树平衡的问题；
       由于M/2的限制，在插入结点时，如果结点已满，需要将结点分裂为两个各占M/2的结点；删除结点时，需将两个不足M/2的兄弟结点合并；

###### 10.3 B+树

B+树是B-树的变体，也是一种多路搜索树：
- 其定义基本与B-树同，除了：以下几个不同
- 非叶子结点的子树指针与关键字个数相同；
- 非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1]]的子树（B-树是开区间）；
- 为所有叶子结点增加一个链指针；
- 所有关键字都在叶子结点出现；
- 如：（M=3）

![](http://p.blog.csdn.net/images/p_blog_csdn_net/manesking/5.JPG)

 B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；

B+的特性：
- 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；
- 不可能在非叶子结点命中；
- 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；
- 更适合文件索引系统；

###### 10.4 B*树
是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；

![](http://p.blog.csdn.net/images/p_blog_csdn_net/manesking/6.JPG)

- B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3（代替B+树的1/2）；
 - B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；
- B*树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；
- 所以，B*树分配新结点的概率比B+树要低，空间使用率更高；

##### 10.5 各类Tree总结

- B树：二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点；
- B-树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；
- B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；
- B*树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3；






