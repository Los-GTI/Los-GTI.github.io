---
layout:     post
title:      混口饭吃专题之Alibaba面经
subtitle:   Alibaba实习面经
date:       2018-04-04
author:     Los-GTI
header-img: img/ms1.jpg
catalog: true
tags:
    - 混口饭吃
---


## first

### Object类有哪些方法

- toString()

- hashCode()：返回对象的Hash值

  ```java
  // String 的 hashCode, hash = s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]
  public int hashCode() {
      int h = hash;
      if (h == 0 && value.length > 0) {
          char val[] = value;

          for (int i = 0; i < value.length; i++) {
              h = 31 * h + val[i];
          }
          hash = h;
      }
      return h;
  }
  ```


- wait()

- notify()

- notifyAll()

- clone()：创建并返回当前对象的一份拷贝。

  一般情况下，对于任何对象 x，表达式 x.clone() **!=** x 为true，x.clone().getClass() == x.getClass() 也为true。

  由于Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。

- equals()：比较两个对象是否相等。Object类的默认实现，即比较2个对象的内存地址是否相等。如果根据equals方法，得到两个对象不相等，那么这2个对象的hashCode值可以一致（但会降低Hash表性能）；反之，equals() 方法为 true，则 hashCode 必须一致。

  ```java
  public boolean equals(Object obj) {
      return (this == obj);
  }
  ```

- getClass()：返回运行时的对象。.class是编译时确定（类属性），.getClass()是运行时才确定（实例方法）

  ```java
  List<Integer> list = new ArrayList<>();         // getClass看new不看前
  System.out.println(List.class);                 // interface java.util.List
  System.out.println(ArrayList.class);            // class java.util.ArrayList
  System.out.println(list.getClass());            // class java.util.ArrayList
  System.out.println(list.getClass().getName());  // java.util.ArrayList
  ```

  ​

- finalize()：该方法的作用是实例被垃圾回收器回收的时候触发的操作，就好比 “死前的最后一波挣扎”。

### Yeild功能

主要作用是：让线程放弃当前的CPU资源，让其他的任务去占用CPU的执行时间。但是执行放弃的时间不定，一般用于debug。

Thread类有三个关键方法：` sleep`、` join` 、`yeild `

- sleep：让当前线程暂停指定的时间（ms），wait方法依赖于同步，而sleep方法可以直接调用。而更深层次的区别在于sleep方法只是暂时让出CPU的执行权，并不释放锁。而wait方法则需要释放锁。

  ```java
  public class SleepTest {

      public synchronized void sleepMethod() {
          System.out.println("Sleep Start...");
          try {
              Thread.sleep(1000);
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
          System.out.println("Sleep End...");
      }
      public synchronized void waitMethod() {
          System.out.println("Wait Start...");
          try {
              wait(1000);
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
          System.out.println("Wait End...");
      }

      public static void main(String[] args) {

          SleepTest sleepTest = new SleepTest();

          for (int i = 0; i < 3; i++) {
              new Thread(() -> sleepTest.sleepMethod()).start();
          }

          try {
              Thread.sleep(10000);
              System.out.println("---------------");
          } catch (InterruptedException e) {
              e.printStackTrace();
          }

          SleepTest waitTest = new SleepTest();

          for (int i = 0; i < 3; i++) {
              new Thread(() -> waitTest.waitMethod()).start();
          }
      }
  }
  ```

  运行结果：

  ```
  Sleep Start...
  Sleep End...
  Sleep Start...
  Sleep End...
  Sleep Start...
  Sleep End...
  ---------------
  Wait Start...
  Wait Start...
  Wait Start...
  Wait End...
  Wait End...
  Wait End...
  ```

  这个结果的区别很明显，通过sleep方法实现的暂停，程序是顺序进入同步块的，只有当上一个线程执行完成的时候，下一个线程才能进入同步方法，sleep暂停期间一直持有monitor对象锁，其他线程是不能进入的。而wait方法则不同，当调用wait方法后，当前线程会释放持有的monitor对象锁，因此，其他线程还可以进入到同步方法，线程被唤醒后，需要竞争锁，获取到锁之后再继续执行。

  ​

- yield：yield方法的作用是暂停当前线程，以便其他线程有机会执行，不过不能指定暂停的时间，并且也不能保证当前线程马上停止。yield方法只是将Running状态转变为Runnable状态。

  ```java
  public class YieldTest implements Runnable{
      @Override
      public void run() {
          try {
              Thread.sleep(1000);
          } catch (InterruptedException e) {
              e.printStackTrace();
          }

          for (int i = 0; i < 5; i++) {
              System.out.println(Thread.currentThread().getName() + ": " + i);
              Thread.yield();
          }
      }

      public static void main(String[] args) {
          YieldTest runn = new YieldTest();
          new Thread(runn, "No.1 Thread").start();
          new Thread(runn, "No.2 Thread").start();
      }
  }
  ```

  运行结果：

  ```java
  No.1 Thread: 0
  No.2 Thread: 0
  No.2 Thread: 1
  No.1 Thread: 1
  No.2 Thread: 2
  No.1 Thread: 2
  No.2 Thread: 3
  No.1 Thread: 3
  No.1 Thread: 4
  No.2 Thread: 4
  ```

  这个例子就是通过yield方法来实现两个线程的交替执行。不过请注意：这种交替并不一定能得到保证

- join：底层是用wait来实现的

### 介绍一下Java中volatile关键字

### 项目中你用到这个关键字吗，用于哪个场景

- 状态标志

- 一次性安全发布（防止调用未加载/初始化的对象）

  ```java
  public class Main {
      public static void main(String[] args) {
          ComplexObject obj = new ComplexObject();
          // 线程1
          new Thread(()->{
              do{
                  if(obj.field != null){
                      break;
                  }
              }while (true);
              System.out.println("exit when obj.field is not null ");
          }).start();
          // 线程2
          new Thread(()->{
              try {
                  Thread.sleep(1000);
                  System.out.println("init obj");
                  obj.init();
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
          }).start();
      }

      static class ComplexObject{
          public volatile ComplexObject field = null;

          public void init(){
              field = new ComplexObject();
          }

      }
  }

  // 线程1会不停的检测复合对象的field属性是否为空，只有当不为空的时候才会结束循环；
  // 而线程2会在启动1秒后才给obj进行初始化；
  // 也就是说，obj对象真正出于发布可用的状态是在线程2中初始化之后，因此这里需要对field属性使用volatile，否则线程2对obj的初始化将对线程1永远不可见，线程1也就不会结束了。
  ```

  ​

- volatile bean：当某个线程对 Java Bean 的属性进行修改时，要保证其他线程都能探测到这个修改，因此这里的属性需要使用`volatile`来修饰。

  ​


### Volatitle关键字声明之后，编译器不会优化的原理

为了解决线程并发问题，Java引入了同步块synchronized关键字与轻量级同步操作volatile关键字。

- **synchronized** ：所有加上synchronized 的块语句和方法，在多线程访问的时候，同一时刻只能有一个线程能够执行这个方法或这段代码。

  使用实例：

  ```java
  public class SynchronizedTest implements Runnable{

      private static int count;

      SynchronizedTest() {
          count = 0;
      }
      @Override
      public synchronized void run() {
  //    public void run() {
          for (int i = 0; i < 4; i++) {
              System.out.println(Thread.currentThread().getName() + ": " + count++);
              try {
                  Thread.sleep(1000);
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
          }
      }

      public static void main(String[] args) {
          SynchronizedTest synchronizedTest = new SynchronizedTest();
          new Thread(synchronizedTest, "No.1 Thread").start();
          new Thread(synchronizedTest, "No.2 Thread").start();
      }
  }
  ```

  运行结果：

  ```java
  // 不使用 synchronized，每次打印结果不一致
  No.1 Thread: 0
  No.2 Thread: 1
  No.2 Thread: 3
  No.1 Thread: 2
  No.1 Thread: 4
  No.2 Thread: 5
  No.2 Thread: 7
  No.1 Thread: 6
      
  // 使用 synchronized，每次打印结果一致
  No.1 Thread: 0
  No.1 Thread: 1
  No.1 Thread: 2
  No.1 Thread: 3
  No.2 Thread: 4
  No.2 Thread: 5
  No.2 Thread: 6
  No.2 Thread: 7
  ```

  ​

- **volatile** ：可以被看作是一种 “程度较轻的 `synchronized`”；与 `synchronized` 块相比，volatile 变量所需的编码较少，并且运行时开销也较少，但是它所能实现的功能也仅是 `synchronized` 的一部分。

  当对非 volatile 的一般变量进行读写时，每个线程先从内存拷贝变量到CPU缓存中，处理后再更新内存中变量的值。然而，如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝变量到不同的CPU cache中。 

  这会带来一个问题，比如说 `i += 1;` 指令，`i` 是一个非 volatile 的静态变量，初始值为0，有两个线程执行了该条指令，按照预期结果，`i` 值将变为 2 。然而线程1将值为0的变量 `i` 拷贝至CPU Cache处理后，还未将值更新回内存，线程2就将值为0的 `i` 拷贝至另外的CPU Cache进行处理。最后得到的结果是令人诧异的 **1** 。

  举个例子：

  ```java
  public class VolatileTest {
      private static int count = 0;

      public static void main(String[] args) {
          for (int i = 0; i < 10000; i++) {
              new Thread(() -> count++).start();
          }
          System.out.println(count); // 结果可能为 9851, 5709, ... 总之每次都不一样！
      }
  }
  ```

  这段程序将用多个线程将变量 `count` 值 + 1 了 10000 次，然而输出结果每次都不固定，并且大概率不是 10000。

  这个时候就需要 volatile 登场了。volatile 变量不会被缓存在处理器不可见的地方（CPU Cache、线程私有区），保证了每次读写变量都是从内存中读，跳过了CPU cache这一步。所以当一个线程修改了这个变量的值，新值对于其他线程来说是立即更新、可知的。 

  不过， volatile 关键字能保证的仅仅是修改可见性，而非有序性，将上述代码修改为：

  ```java
  public class VolatileTest {
      private static volatile int count = 0;

      public static void main(String[] args) {
          for (int i = 0; i < 10000; i++) {
              new Thread(() -> count++).start();
          }
          System.out.println(count); // 结果可能为 9851, 5709, ... 总之每次仍然不一样！
      }
  }
  ```

  因为负责打印的main线程与count+1的线程执行顺序是混乱的，所以会导致上述结果。

  修改代码如下：

  ```java
  public class VolatileTest {
      private static volatile int count = 0;

      public static void main(String[] args) {
          for (int i = 0; i < 10000; i++) {
              new Thread(() -> count++).start();
          }
          try {
              Thread.sleep(1000);  // 等待自增线程执行完毕
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
          System.out.println(count); // 打印结果为10000
      }
  }

  // 或是使用atomic包

  public class VolatileTest {
      private static AtomicInteger count = new AtomicInteger(0);

      public static void main(String[] args) {
          for (int i = 0; i < 10000; i++) {
              new Thread(() -> count.incrementAndGet()).start();
          }
          try {
              Thread.sleep(1000);
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
          System.out.println(count.get());
      }
  }
  ```

  ​

  关于 volatile 关键字的适用场景可参考：[正确使用 Volatile 变量](https://www.ibm.com/developerworks/cn/java/j-jtp06197.html)

  我们只能在有限的一些情形下使用 volatile 变量替代锁。要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件：

  - 对变量的写操作不依赖于当前值。（比如说`i = 10 ` 不依赖当前 `i` 值，而 `i++` 依赖）
  - 该变量没有包含在具有其他变量的不变式中。（比如说不能将该变量用于边界检查，因为修改不保证有序，很有可能这个变量会同时满足 `i < 3 ` 和 `i > 4` ，薛定谔的变量值。。）

  除了保证变量的内存可见性外，volatile 关键字的一大功能是禁止指令重排，即关闭JVM中必要的代码优化，其实现原理是提供内存屏障的方式来防止指令被重排：

  1. 每个volatile写操作的前面插入一个StoreStore屏障；
  2. 在每个volatile写操作的后面插入一个StoreLoad屏障；
  3. 在每个volatile读操作的后面插入一个LoadLoad屏障；
  4. 在每个volatile读操作的后面插入一个LoadStore屏障。





### Java中Session和Cookie

二者是保存会话数据的两种技术。

- Session 是服务端技术，利用这个技术，服务器在运行时可以为每一个用户（浏览器）的数据创建一个其独享的 Session 对象，当用户在访问服务器的web资源时，服务器可以把各自的数据放入各自的 Session 中，当用户再次访问web服务时，该web服务会从用户对应的 Session 中取出数据为用户提供服务。
- Cookie 是客户端技术，web服务把用户的数据以 Cookie 的形式写入用户各自的浏览器。当用户使用浏览器再去访问服务器的web资源时，就会携带各自的数据去访问。这样，web服务器就能针对不同用户进行处理。

Cookie 方法：

- `Cookie(String name, String value)` ：设置新 Cookie 数据；
- `setValue 与 getValue` ：设置/获取 Cookie 值；
- `setMaxAge 与 getMaxAge方法` ：设置Cookie的有效期，默认的有效期是会话范围的，会话结束，Cookie结束（存在缓存中）；
- `setPath 与 getPath 方法`：设置Cookie的有效目录，例如：/demo，那么访问demo目录下的所有web资源，都会携带Cookie。默认有效目录为当前创建 Cookie 的程序的目录；
- `setDomain 与 getDomain 方法` ：设置Cookie的有效域，例如： .sina.com，前面有点。这个方法实际用处不大，浏览器会阻止第三方 Cookie，只识别本域中的 Cookie；
- `getName 方法` ：获取Cookie的名称。

Session 类：`javax.servlet.http.HttpSession` ，使用和 Cookie 类似，比 Cookie 略方便（无需序列化），但是过多的 Session 存储在服务器内存中，会对服务器造成压力。只有访问 JSP、Servlet 等程序时才会创建 Session，单纯访问 HTML、IMAGE 等静态资源并不会创建 Session。

URL 地址重写是对客户端不支持 Cookie 的解决方案。URL地址重写的原理是将该用户Session的id信息重写到URL地址中。服务器能够解析重写后的URL获取Session的id。这样即使客户端不支持Cookie，也可以使用Session来记录用户状态。

### Cookie 如果我不想js或http读，应该设置什么属性

js：httpOnly属性

http：secure属性

### 里面有个属性httpOnly，这个属性你了解吗

当 Cookie 带 `httpOnly` 选项时，客户端则无法通过 js 代码去访问（包括读取、修改、删除等）这个 Cookie 。

### 如何防止跨站点攻击

>  “所有用户输入都是不可信的。”

- XSS Filter （输入过滤、输出转义）
- 使用 HttpOnly Cookie
- 使用无需刷新的 url 来控制 View




### 分布式 Session 

分布式Session有如下几种实现方式。

1. Session复制

在支持Session复制的Web服务器上，通过修改Web服务器的配置，可以实现将Session同步到其它Web服务器上，达到**每个Web服务器上都保存一致的Session**。
优点：代码上不需要做支持和修改。
缺点：需要依赖支持的Web服务器，一旦更换成不支持的Web服务器就不能使用了，在数据量很大的情况下不仅占用网络资源，而且会导致延迟。
适用场景：只适用于Web服务器比较少且Session数据量少的情况。
可用方案：开源方案tomcat-redis-session-manager，暂不支持Tomcat8。

2. Session粘滞

将用户的每次请求都**通过某种方法强制分发到某一个Web服务器上**，只要这个Web服务器上存储了对应Session数据，就可以实现会话跟踪。
优点：使用简单，没有额外开销。
缺点：一旦某个Web服务器重启或宕机，相对应的Session数据将会丢失，而且需要依赖负载均衡机制。
适用场景：对稳定性要求不是很高的业务情景。

3. Session集中管理

在单独的服务器或服务器集群上使用缓存技术，如Redis存储Session数据，集中管理所有的Session，所有的Web服务器都从这个存储介质中存取对应的Session，实现**Session共享**。
优点：可靠性高，减少Web服务器的资源开销。
缺点：实现上有些复杂，配置较多。
适用场景：Web服务器较多、要求高可用性的情况。
可用方案：开源方案Spring Session，也可以自己实现，主要是重写HttpServletRequestWrapper中的getSession方法，博主也动手写了一个，github搜索joincat用户，然后自取。

4. 基于Cookie管理

这种方式每次发起请求的时候都需要**将Session数据放到Cookie中传递给服务端**。
优点：不需要依赖额外外部存储，不需要额外配置。
缺点：不安全，易被盗取或篡改；Cookie数量和长度有限制，需要消耗更多网络带宽。
适用场景：数据不重要、不敏感且数据量小的情况。

总结
这四种方式，相对来说，Session集中管理更加可靠，使用也是最多的。


### Java中Synchronized，Lock的区别

用法区别：

- synchronized：**隐式锁**，可以加在方法、类、代码块上；
- Lock：**显式锁**，需要显示指定起始位置和终止位置。

性能区别：

- synchronized：**JVM托管**，字节码控制；
- Lock：**Java代码控制**。

内部机制区别：

- synchronized：**悲观锁机制**，线程获得独占锁，其他线程只能等待当前线程阻塞；
- Lock：**乐观锁机制** ，CAS（Compare and Swap）操作（乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息同时进行事务回滚）



### Synchronized能被中断吗

不能，如果A不释放，B将一直等下去，不能被中断。

### Lock中提供了中断的方法吗，这个方法是哪个

lockInterruptibly();

参考：http://blog.csdn.net/natian306/article/details/18504111

### 消费者生产者模型你是怎么实现的

首先要实现一个阻塞队列，可以考虑用 wait/notifyAll 或 Lock/Condition 两套方案，也可以考虑直接使用concurrent 里的 BlockingQueue 来实现

### ！如果当前线程被锁，其它线程干嘛



### 具体在哪个场景中使用这个，业务背景

处理订单、报警记录、消息队列。

### ？在工程中用的还是分布式管理

### hashMap是怎么管理的

- put 方法原理

1. 对 key 的 hashCode() 做 hash，计算出 index;
2. 如果没碰撞直接放到bucket里；
3. 如果碰撞了，以链表的形式存在 buckets 后；
4. 如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树；
5. 如果节点已经存在就替换 old value (保证key的唯一性)
6. 如果bucket满了(超过load factor*current capacity)，就要 resize。

- get 方法原理

1. 对 key 的 hashCode() 做 hash，计算出 index;
2. 根据 index 查看 bucket
3. 如果 bucket 里的第一个节点 key.equals(k) 为 true，则直接命中；
4. 否则将通过 key.equals(k) 去查找对应的 entry。

- 如果待插入元素和 HashMap 中某元素的 key 的 hashCode 相同会怎么样？

put 方法先根据 hashCode 定位 bucket ，会出现碰撞，再根据 key.equals(k) 去访问，如果返回 true 则更新旧值（key相同hash也相同），如果遍历链表没有返回 true 的节点（key不同但是hash相同，即hash冲突），则会插入新的节点。

- 如果两个不同键的 hashcode 相同，你如何获取值对象？

get 方法先根据 hashCode 定位 bucket，再遍历链表/红黑树节点，找到 key.equals(k) 返回 true 的 Entry 节点，最后返回该 Entry 的 value。

- resize 方法原理

简单的说，就是把bucket扩充为 2 倍（n <<= 1），之后重新计算 index，把节点再放到新的 bucket 中。

hash 值不变，计算 index 方式为根据 hash 值新增 bit （因为 n 左移了一位，所以hash的有效位增加了一位，我们称之为新增 bit）来判定，若新增 bit 为 0，则节点无需移动；若新增 bit 为1，则节点需移动 $2^{n-1}$ 的位置。

该过程中链表元素将会 reverse 。

若多线程环境，多个线程检测到需要调整大小，则同时执行 resize 方法，同时进行 reverse 操作，进而产生条件竞争，陷入死循环。

- 为什么String, Interger这样的wrapper类适合作为键？

1是 String 不可变

### 线程安全版本你用过吗



### ConcurrentHashMap用过吗，讲一下原理

分段锁机制

### 怎么执行读时被锁



除了分段锁还有什么原理

怎么用于分布式

### 线程本地变量原理和实现原理

ThreadLocal是线程内部的数据存储类，通过它可以指定的线程中存储数据，数据存储以后，只有在指定线程中可以获取到存储的数据，对于其他线程来说则无法获取数据. 



### 线程本地变量大概有什么数据结构，怎么实现的

ThreadLocalMap



### 介绍一下java的内存模型

堆、栈（native方法栈、虚拟机栈）、程序计数器、方法区（常量池）。

![](http://gityuan.com/images/jvm/jvm_memory_1.png)

（1）线程私有区：

- 程序计数器，记录正在执行的虚拟机字节码的地址；
- 虚拟机栈：方法执行的内存区，每个方法执行时会在虚拟机栈中创建栈帧；
- 本地方法栈：虚拟机的Native方法执行的内存区；

（2）线程共享区：

- Java堆：对象分配内存的区域；
- 方法区：存放类信息、常量、静态变量、编译器编译后的代码等数据；
  - 常量池：存放编译器生成的各种字面量和符号引用，是方法区的一部分。

### 线程本地变量存在哪的

栈区



### JVM的DDM参数你有调优过吗，设置大小和原则你能介绍一下吗



### Xss默认大小，在实际项目中你一般会设置多大

每个线程的堆栈大小，JDK5.0以后每个线程堆栈大小为1M。

一般用默认的，或者严格的 256 K



### 数据库主键和外键有什么区别

- 定义：

主键：唯一标识一条记录，不能有重复，不允许为空。
外键：表的外键是另一表的主键，外键是可以有重复的，可以是空值。
索引：该字段没有重复值，但可以有一个空值。

- 作用：

主键：用来保证数据完整性
外键：用来和其他表建立联系用
索引：用来提高查询排序的速度

- 个数：

主键：主键只能有一个。
外键：一个表可以有多个外键。
索引：一个表可以有多个唯一索引。

### 数据库视图和表有什么区别

表：具体的，实际物理记录

视图：抽象的，依附表而存在，删除不影响实际物理表。



### 数据事务你能简单介绍一下吗，ACID

一个数据库事务通常包含了一个序列的对数据库的读/写操作。它的存在包含有以下两个目的：

1. 为数据库操作序列提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。
2. 当多个[应用程序](https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F)在[并发](https://zh.wikipedia.org/wiki/%E5%B9%B6%E5%8F%91)访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。

 数据库事务必须具备ACID特性，ACID是Atomic（原子性）、Consistency（一致性）、Isolation（隔离性）和Durability（持久性）的英文缩写。

　 原子性：指整个数据库事务是不可分割的工作单位。只有使据库中所有的操作执行成功，才算整个事务成功；事务中任何一个SQL语句执行失败，那么已经执行成功的SQL语句也必须撤销，数据库状态应该退回到执行事务前的状态。

　 一致性：指数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。例如对银行转帐事务，不管事务成功还是失败，应该保证事务结束后ACCOUNTS表中Tom和Jack的存款总额为2000元。

　 隔离性：指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，**事务不会查看到中间状态的数据**。

　 持久性：指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来。即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。

　　事务的（ACID）特性是由关系数据库管理系统（RDBMS，数据库系统）来实现的。数据库管理系统采**用日志来保证事务的原子性、一致性和持久性**。日志记录了事务对数据库所做的更新，如果某个事务在执行过程中发生错误，就可以根据日志，撤销事务对数据库已做的更新，使数据库退回到执行事务前的初始状态。

　　数据库管理系统**采用锁机制来实现事务的隔离性**。当多个事务同时更新数据库中相同的数据时，只允许持有锁的事务能更新该数据，其他事务必须等待，直到前一个事务释放了锁，其他事务才有机会更新该数据。



### 事务特性分别什么特征，什么原理

ACID



### Mysql数据库隔离级别一般用哪个

**Read Uncommitted（读取未提交内容）**

在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。

**Read Committed（读取提交内容）**

这是大多数数据库系统的默认隔离级别（sqlserver、但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。

**Repeatable Read（可重读）**

**这是MySQL的默认事务隔离级别**，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。

**Serializable（可串行化）**

这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。

这四种隔离级别采取不同的锁类型来实现，若读取的是同一个数据的话，就容易发生问题。例如：

**脏读**(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。

**不可重复读**(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。

**幻读**(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。



### Hibernate隔离级别一般用的哪个

2和4比较多，可重读

### 数据库大概怎么实现的索引，底层用了什么数据结构，大概介绍一下

B树及其变种B+树

B树中每个节点包含了键值和键值对于的数据对象存放地址指针，所以成功搜索一个对象可以不用到达树的叶节点。

B+树非叶节点中存放的关键码并不指示数据对象的地址指针，非也节点只是索引部分。所有的叶节点在同一层上，包含了全部关键码和相应数据对象的存放地址指针，且叶节点按关键码从小到大顺序链接。

### ！分布式系统，分布式工作原理





### 介绍ARP协议是干什么的

通过[网络地址](https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E4%BD%8D%E5%9D%80)(例：[IPv4](https://zh.wikipedia.org/wiki/IPv4))来定位[MAC地址](https://zh.wikipedia.org/wiki/MAC%E5%9C%B0%E5%9D%80) (也称为以太地址)，网络层定位链路层

### Http请求底层是用的什么协议

TCP

### Tcp连接过程

![](http://img.blog.csdn.net/20140608195019968?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbnNfY29kZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

![](http://img.blog.csdn.net/20140608204149078?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbnNfY29kZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

### 连接时队列大小是什么原理

- server端的半连接队列(syn队列)，内核决定，net.ipv4.tcp_max_syn_backlog
- server端的完全连接队列(accpet队列)，min(net.core.somaxconn，backlog)，内核参数和自定义的最小值

### DNS协议作用，底层用的什么协议

可以将域名转换为[IP地址](https://zh.wikipedia.org/wiki/IP%E5%9C%B0%E5%9D%80)，UDP



### 语法解析、词法解析

词法解析 -> 语法解析 -> 语义解析

识别单词->组合单词，单句判断->上下文判断

### 编译步骤分几个部分

预处理、编译、汇编、链接

编译程序常用表达方法



### 进程通信有哪些方式

1. 管道
2. 消息队列
3. 共享内存
4. PV操作（信号量机制）

### 进程和线程有什么区别

1. 进程独占内存，线程共享内存
2. 进程是资源分配单位，线程是CPU调度单位
3. 线程切换与进程切换无关，进程切换线程一定切换

### 文件描述符是共享的还是私有的

线程共享



### 什么是死锁

竞争资源而引起的相互等待

4个条件：互斥、不剥夺、循环等待、请求/保持

### ！Java中你碰到过死锁吗



### ！Mysql中碰到过死锁吗

相同表记录行锁冲突

一个要更新 [1, 2, 3, 4]， 一个更新 [4, 5, 6, 1]



### 虚拟内存是什么原理

程序分页，根据置换算法，将常用页调入内存。

### 一页大小大概多少

1~4KB

### 换页中最近最长未使用算法简单的实现

LinkedHashMap

每访问一次数据，都把最新的访问的数据放到了链表头部，那链表尾部的数据就是最近没有访问过的数据！！ 当链表满了，从链表尾部开始往前删除指定数目的数据，就能在常数级时间内腾出空间！

### ！除外链表相应算法你了解过吗



### 堆排序大概是怎么实现的

### 堆排序你使用过吗，是用的怎样的底层存储，数据结构

优先队列

底层是用的数组，逻辑上是怎样的结构

### 求第五大的算法是什么原理，直接求，不用排序

快排思路，递归另一半。

本问题中，假设 N 个数存储在数组 S 中，我们从数组 S 中随机找出一个元素 X，把数组分为两部分 Sa 和 Sb。Sa 中的元素大于等于 X，Sb 中元素小于 X。
这时，有两种可能性：

1. Sa中元素的个数小于K，Sa中所有的数和Sb中最大的K-|Sa|个元素（|Sa|指Sa中元素的个数）就是数组S中最大的K个数。
2. Sa中元素的个数大于或等于K，则需要返回Sa中最大的K个元素。

### 搜索算法PN你知道吗，字符串查找

不知道

### 介绍一下你学过哪些搜索算法

字符串搜索：kmp、trie树，两者结合的ac自动机

图搜索：dfs、bfs、dijkstra、A star



B 用于外排为什么效率会比较高

### B 树结点大小一般是多大

磁盘块大小有关，1~4k左右

### Hash算法是什么，为什么会有Hash算法

一种以较短的信息来保证文件或是对象唯一性的标志，快速定位

### 一般采用的Hash冲突有哪些解决方案

拉链法

开放定址

### 一次性Hash你有了解吗

负载均衡、环形空间、减少数据迁移



### Redis的哪些常见的数据结构

list、set、zset、string、hash

### 怎么保证分布式Catch出现脏数据

### Maven包冲突怎么解决

tree命令查看层级树

### Maven怎么把所有包打包

package

### Linux中怎么看日志中某个时间段某个网站被各个ip访问的次数

```bash
#!/bin/bash
#将28/Jan/2015全天的访问日志放到a.txt文本
cat access.log |sed -rn '/28\/Jan\/2015/p' > a.txt 
#统计a.txt里面有多少个ip访问
cat a.txt |awk '{print $1}'|sort |uniq > ipnum.txt
#通过shell统计每个ip访问次数
for i in `cat ipnum.txt`
do 
iptj=`cat  access.log |grep $i | grep -v 400 |wc -l`
echo "ip地址"$i"在2015-01-28日全天(24小时)累计成功请求"$iptj"次，平均每分钟请求次数为："$(($iptj/1440)) >> result.txt
done
```



### Linux中解压命令是什么

tar



项目中你用过最高深的技术，能大概介绍一下吗

你现在在看什么书

书中你觉得你比较有体会的有价值的

### Java8

lambda、性能调优

你介绍一下你技术方面学习规划



你有什么问题想问我的吗



## second

https://www.nowcoder.com/discuss/3836

### （1）自我介绍。 

略

### （2）JVM如何加载一个类的过程，双亲委派模型中有哪些方法？ 

类加载过程：加载、验证、准备、解析、初始化（LVPRI）

- 加载（Loading）：根据类全限定名加载二进制字节流，将二进制字节流的静态存储结构转化为动态数据结构，在内存中（Java堆）初始化一个 java.lang.Class 对象，作为方法区访问该类的入口

- 验证（Verification）：验证字节流是否符合JVM规范

- 准备（Preparation）：为类的static变量分配内存，并赋初值（final变量赋真实值，非final变量赋0）

- 解析（Resolution）：把符号引用替换为直接引用

- 初始化（Initialization）：进一步初始化（父类、构造函数）


双亲委派模型：

启动类加载器（Bootstrap）、扩展类加载器（Extend）、应用程序类加载器（Application）、自定义类加载器（User）

组合方式实现，而非继承。

首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。

```java
protected synchronized Class<?> loadClass(String name, boolean resolve)   throws ClassNotFoundException{  
    // First, check if the class has already been loaded  
    Class c = findLoadedClass(name);  
    if (c == null) {  
        try {  
            if (parent != null) {  
                c = parent.loadClass(name, false);  
            } else {  
                c = findBootstrapClassOrNull(name);  
            }  
        } catch (ClassNotFoundException e) {  
            // ClassNotFoundException thrown if class not found  
            // from the non-null parent class loader  
        }  
        if (c == null) {  
            // If still not found, then invoke findClass in order  
            // to find the class.  
            c = findClass(name);  
        }  
    }  
    if (resolve) {  
        resolveClass(c);  
    }  
    return c;  
}  
```



###   （3）HashMap如何实现的？ 

HashMap 底层就是一个数组，数组中的每一项又是一个链表（jdk1.8有可能为红黑树）。

当新建一个 HashMap 的时候，就会初始化一个数组。

根据对象的 hashCode 方法在数组中定位元素，再根据 equals 方法在链表中定位节点。

###   （4）HashMap 和 Concurrent  HashMap区别，  Concurrent  HashMap  线程安全吗，  Concurrent  HashMap如何保证 线程安全？

是否线程安全：ConcurrentMap 采用了分段锁的机制，在进行多线程写操作时只需要为写入位置所在的 segment  加锁，以确保同一时刻只有一个线程修改这个segment的数据

###   （5）HashMap 和 HashTable  区别，HashTable线程安全吗？

略

###   （6）进程间通信有哪几种方式？

1. 低级通信方式：PV操作
2. 高级（管道、消息队列、共享内存）

###   （7）JVM分为哪些区，每一个区干吗的？

方法区（包含常量池）、Java 堆、虚拟机栈、native栈、程序计数器

###   （8）JVM如何GC，新生代，老年代，持久代，都存储哪些东西？

分代收集算法。

- 年轻代：对象被创建时，内存的分配首先发生在年轻代（大对象可以直接被创建在年老代）。使用**复制算法**回收（即当Eden区满的时候，执行Minor GC，将消亡的对象清理掉，并将剩余的对象复制到一个存活区Survivor0；如果Eden区又满了，再执行一次Minor GC，将消亡的对象清理掉，将存活的对象复制到Survivor1中，然后清空Eden区；将Survivor0中消亡的对象清理掉，将其中可以晋级的对象晋级到Old区，将存活的对象也复制到Survivor1区，然后清空Survivor0区；）
- 老年代：在几次Young GC后存活了下来，则会被复制到年老代。**标记-整理算法**，即：标记出仍然存活的对象（存在引用的），将所有存活的对象向一端移动，以保证内存的连续。
- 持久代：方法区的东西。回收主要针对常量池中的常量，无用的类信息。清理时需保证 1. 所有实例被回收；2. 对应的ClassLoader被回收；3. 没有反射引用

###   （9）GC用的引用可达性分析算法中，哪些对象可作为GC Roots对象？

- 虚拟机栈、Native栈中引用的对象；
- 方法区类静态属性引用的对象（static）；
- 方法区中常量引用的对象（final）；

###   （10）快速排序，过程，复杂度？

略

###   （11）什么是二叉平衡树，如何插入节点，删除节点，说出关键步骤。

左右子树高度相差不超过1的二叉查找树；

插入节点：递归插入，若插入后不平衡，则做调整。

删除节点：同上。

###   （12）TCP如何保证可靠传输？三次握手过程？

**可靠传输：**

1. 确认、重传机制（滑动窗口实现）
2. 数据校验
3. 数据合理分片与排序
4. 拥塞控制（慢开始和拥塞避免、快恢复和快重传）
5. 流量控制（滑动窗口）

**三次握手的过程：**

1. 客户端发送syn报文（client: SYN_SENT)
2. 服务端接收syn报文，发送syn+ack报文（server: SYN_RECV）
3. 客户端接收syn+ack报文，发送ack报文（client: Established）
4. 服务端接收到syn报文，连接建立（server: Established）

###   （13）TCP和UDP区别？

1. TCP 面向连接，UDP 面向无连接
2. TCP 传输可靠，UDP 不可靠
3. TCP 大量数据（数据流），UDP 少量数据（数据包）
4. TCP 较慢，UDP 较快

###   （14）滑动窗口算法？

![](https://coolshell.cn/wp-content/uploads/2014/05/tcpswwindows.png)

- 1已收到ack确认的数据。
- 2发还没收到ack的。
- 3在窗口中还没有发出的（接收方还有空间）。
- 4窗口以外的数据（接收方没空间）



1. A发送帧1，发完帧1后并不等待帧1已经发送成功的信号就发送帧2，发完帧2后就发送帧3，此时才进入等待状态(因为窗口是3，满了)。
2. 经过一些延时后，B接收到帧1，然后B发送给A“已收到帧1的信号”，然后B又接收到帧2，然后B发送给A“已收到帧2的信号”，然后是帧3。。。
3. 经过一些延时后，若A先收到了“B收到帧1的信号”，再收到“B收到帧2的信号”，再收到“B收到帧3的信号”，那说明第一个窗口发送成功，A转而进入下一个窗口的发送过程中(即跳转到步骤4)；若这3个信号中只要其中1个或1个以上A没有收到，那么说明第一个窗口发送失败，那么A要重新发送帧1，帧2，帧3(注意，3个都要重发，而不是只重发没收到接收信号的那个，即跳转到步骤1)。
4. A发送帧4，发完帧4后发送帧5，然后进入等待状态。



**多个一起发，收到一个帧返回一个ack；只要一个帧没收到，则多个一起重发；全部收到则发下一批帧**

###   （15）Linux下如何进行进程调度的？

进程提供了两种优先级，一种是**普通优先级**，第二个是**实时优先级**。

**任何时候，实时进程的优先级都高于普通进程**，实时进程只会被更高级的实时进程抢占，同级实时进程之间是按照FIFO（一口气做完，其他进程不得强占）或者RR（同优先级进程多次轮转）规则调度的。

###   （16）Linux下你常用的命令有哪些？

操作类：cd、ls、mv、rm、mkdir、grep

工具类：screen、vim、crontab

###   （17）操作系统什么情况下会死锁？

资源不足。

必要条件4个：

- 互斥：一个资源只能一个进程占用
- 不剥夺/非抢占
- 循环等待：P1等P2，P2等P3，P3等P1
- 请求保持：阻塞时不释放占有的资源

###   （18）常用的hash算法有哪些？

MD4、MD5、SHA-1

常用的构造hash函数方法：

- 模除
- 线性变换
- 随机因子

###   （19）什么是一致性哈希？

负载均衡、环形空间、减少数据迁移

原理是通过使用与对象存储一样的Hash算法将机器也映射到环中，然后以顺时针的方向计算，将所有对象存储到离自己最近的环节点中。

**一致哈希** 是一种特殊的[哈希](https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C)算法。在使用一致哈希算法后，哈希表槽位数（大小）的改变平均只需要对![K/n](https://wikimedia.org/api/rest_v1/media/math/render/svg/48c6b98bc4a3841f616b526a8e03e3ede6659839) 个关键字重新映射，其中![K](https://wikimedia.org/api/rest_v1/media/math/render/svg/2b76fce82a62ed5461908f0dc8f037de4e3686b0)是关键字的数量，![n](https://wikimedia.org/api/rest_v1/media/math/render/svg/a601995d55609f2d9f5e233e36fbe9ea26011b3b)是槽位数量。然而在传统的[哈希表](https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8)中，添加或删除一个槽位的几乎需要对所有关键字进行重新映射。

###   （20）如何理解分布式锁？

一个订单，一台设备处理。

- 数据库锁表：把order_id设置为了`UNIQUE KEY`，所以同一个订单号只能插入一次。于是对锁的竞争就交给了数据库，处理同一个订单号的交易中心把订单号插入表中，数据库保证了只有一个交易中心能插入成功，其他交易中心都会插入失败。
- 分布式缓存锁—Redlock算法（利用Redis实现）
- 更好的分布式锁—zookeeper

###   （21）数据库中的范式有哪些？

- **1NF**：指数据库表的每一列都是不可分割的基本数据项
  在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。

- **2NF**：要求非主属性完全依赖于主键

  比如说课表（学号、课程号、姓名、学分、成绩），主键是（学号、课程号），姓名只是部分依赖于主键，即仅需学号就可确定姓名；学分同理。不满足2NF会产生4个问题：

  - 数据冗余：比如同样的课程学分需要存储多次
  - 更新异常：更新一门课的教师，需要更新所有选了该课的课表行，否则会出现同课不同师
  - 插入异常：只插课，不插学生（还没选课），会报错
  - 删除异常：学生删了这门课，相关的老师、成绩、学分信息就全没了

- **3NF**：消除2NF的传递依赖

  比如某个表学生信息（学号、姓名、学院号、学院名），学院号就能确定学院名，可以拆成学生信息、学院信息两张表。

- **BCNF**：在满足第三范式的基础上，且不允许主键的一部分被另一部分或其它部分决定。

###   （22）数据库中的索引的结构？什么情况下适合建索引？

**页是InnoDB存储引擎管理数据库的最小磁盘单位。** B+Tree的一个叶node即是一个页，存放的是表中行的实际数据。InnoDB中的页大小为16KB，且不可以更改

b，b+树



主键，外键，where（条件查询）,  group by（分组）,  order by（排序）



**InnoDB索引和MyISAM索引的区别：**

- 一是主索引的区别，InnoDB的数据文件本身就是索引文件。而MyISAM的索引和数据是分开的。
- 二是辅助索引的区别：InnoDB的辅助索引data域存储相应记录主键的值而不是地址。而MyISAM的辅助索引和主索引没有多大区别。

###   （23）Java中的BIO，NIO，AIO分别是什么？ 

- BIO，**同步阻塞式IO**，简单理解：**一个连接一个线程**；客户端建立Socket时就会询问是否有线程可以处理，如果没有，要么等待，要么被拒绝。
- NIO，**同步非阻塞IO**，加入了 Buffer、Channel、Selector 概念，简单理解：**一个请求一个线程**；即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有IO请求时才启动一个线程进行处理。
- AIO，**异步非阻塞IO**，简单理解：**一个有效请求一个线程**；客户端的IO请求都是由OS先完成了再通知服务器应用去启动线程进行处理。

###   （24）用什么工具调试程序？JConsole，用过吗？ 

- jdb：

  ```shell
  jdb -classpath bin com.xx.Example
  jdb -connect com.sun.jdi.SocketAttach:hostname=myhost,port=8000
  jdb -connect "com.sun.jdi.CommandLineLaunch:main=Hello 1 2 3"
  ```

- JConsole，JVisualvm（前者升级版）：图形化

- IDEA自带

- jinfo/jmap/jhat/jstack/jstat

###   （25）现在JVM中有一个线程挂起了，如何用工具查出原因？ 

Javacore 是一个当前 JVM 运行状态的快照。通过对 Javacore 的分析，可以了解在 JVM 中运行的应用程序的当前状态，比如是否“卡”在某一点上，或在某些代码上运行时间太长。

###   （26）线程同步与阻塞的关系？同步一定阻塞吗？阻塞一定同步吗？ 

1、同步就是指一个线程要等待上一个线程执行完之后才开始执行当前的线程。
2、异步是指一个线程去执行，它的下一个线程不必等待它执行完就开始执行。同步异步与阻塞无关，但是一般同步IO等于阻塞IO，同步方法理论上只会调用同步IO，异步方法两者都会调用。所以同步必阻塞，阻塞不一定同步。



**直观解释：**

- 阻塞 I/O：等水烧开，不做其他事。（等待数据准备好，不做其他事）
- 非阻塞 I/O：水烧着去看电视，每几分钟检查一下水烧开没。
- 异步 I/O：水烧着去看电视，水烧开后会响，响了再去看。（准确说是异步非阻塞 I/O，一般不存在异步阻塞 I/O）



**所以同步/异步在于是否轮询，阻塞/非阻塞在于是否干等。**



###   （27）同步和异步有什么区别？ 

同步（synchronize）、异步（asychronize）关注的是**消息通信机制**。

所谓同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。简而言之，就是**由调用者主动等待这个调用结果。** 通常所说的线程安全基本上就是指是同步的。

**使用同步IO时，Java自己处理IO的读写**

所谓异步，跟同步相反。调用在翻出之后，这个调用就直接返回了，所以没有返回结果。换句话说，就是当一个异步进程调用发出之后，调用者不会立刻得到结果。而是在调用发出之后，被调用者通过状态、通知来通知调用者，或者通过回调函数来处理这个调用。

**使用异步IO时，Java将IO读写委托给OS处理**，需要将数据缓冲区地址和大小传给OS，OS需要支持异步IO操作。

###   （28）线程池用过吗？ 

线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。。

线程池作用就是限制系统中执行线程的数量。 

我想做一个新闻应用，ListView上有一个item，每个item上都有一张图片需要从网络上加载，如果不使用线程池，会有以下问题：

- 频繁触发GC
- 互相竞争
- 无法控制（即开始了就没法停）

###   （29）如何创建单例模式？说了双重检查，他说不是线程安全的。如何高效的创建一个线程安全的单例？ 

内部静态类；

而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。

```java
public class Singleton {  
    private static class SingletonHolder {  
    	private static final Singleton INSTANCE = new Singleton();  
    }  
    private Singleton (){}  
    public static final Singleton getInstance() {  
    	return SingletonHolder.INSTANCE;  
    }  
}  
```

枚举：

```java
public enum Singleton {  
    INSTANCE;  
    public void whateverMethod() {  
    }  
} 
```

DCL：

```java
public class Singleton {  
    private volatile static Singleton singleton;  
    private Singleton (){}  
    public static Singleton getSingleton() {  
    	if (singleton == null) {  
        	synchronized (Singleton.class) {  
        		if (singleton == null) {  
            		singleton = new Singleton();  
        		}  
        	}  
    	}  
    	return singleton;  
    }  
}  
```



###   （30）concurrent包下面，都用过什么？ 

- **Executor**：具体Runnable任务的执行者。线程池


- **Semaphore**：一个计数信号量
- **ReentrantLock** ：一个可重入的互斥锁定 Lock，功能类似synchronized，但要强大的多。


- **BlockingQueue**             ：阻塞队列。
- **Atomic**：原子操作

CompletionService         : ExecutorService的扩展，可以获得线程执行结果的
CountDownLatch            ：一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。 
CyclicBarrier             ：一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 
Future                    ：Future 表示异步计算的结果。
ScheduledExecutorService ：一个 ExecutorService，可安排在给定的延迟后运行或定期执行的命令

  （31）常用的数据库有哪些？redis用过吗？ 

  （32）了解hadoop吗？说说hadoop的组件有哪些？hdfs，hive,hbase,zookeeper。说下mapreduce编程模型。 

###   （33）你知道的开源协议有哪些？ 

- GPL（Linux，用了就得开源）

- BSD（为所欲为，除了用你的软件打广告）

- MIT（为所欲为，包括用你的软件打广告）

  （34）你知道的开源软件有哪些？ 

  （35）你最近在看的书有哪些？ 

  （36）你有什么问题要问我吗？ 

  基本上就这样了，还有一些零星的问题想不起来了，从7点到8点多，持续了一个多小时。我想说，我的手好累啊。。下次一定要戴个耳机。 

  又想起来几个。 

  （37）了解哪些设计模式？说说都用过哪些设计模式 

  （38）如何判断一个单链表是否有环？ 

  （39）操作系统如何进行分页调度？ 

  （40）匿名内部类是什么？如何访问在其外面定义的变量？



## Third

### 听说你有博客，博客里大概有什么内容？

略

### 项目介绍，最复杂的表

略

### Hashmap的原理

略

### Hashmap为什么大小是2的幂次

计算 Hash 值用到了模除，如果大小是 2 次幂，则可以使用位运算来加速 Hash 运算，`h & (length-1);  ` 

负载因子是在时间和空间成本上寻求一种折衷，加载因子过高虽然减少了空间开销，但同时也增加了查询成本。

### 介绍一下红黑树

红黑树本质上就是一棵二叉查找树，查找、插入、删除的时间复杂度最坏为O(log n)；

定义如下：

```
1）每个结点要么是红的，要么是黑的。  
2）根结点是黑的。  
3）每个叶结点（叶结点即指树尾端NIL指针或NULL结点）是黑的。  
4）如果一个结点是红的，那么它的俩个儿子都是黑的。即从每个根到节点的路径上不会有两个连续的红色节点，但黑色节点是可以连续的。 
5）对于任一结点而言，其到叶结点树尾端NIL指针的每一条路径都包含相同数目的黑结点。  
```

AVL更平衡，结构上更加直观，时间效能针对读取而言更高；维护稍慢，空间开销较大。

红黑树，读取略逊于AVL，维护强于AVL，空间开销与AVL类似，内容极多时略优于AVL，维护优于AVL。**插入至多只需要进行2次旋转就可以完成，对于删除，至多只需要三次就可以完成，所以其统计性能要比AVL树好**

Splay Tree，读取维护速度不稳定，属于理论上的统计logN时间复杂度，特殊情况下能直接退化为链表，空间最节省，部分功能优于前两者。

Treap，速度快，功能有缺失。

### Arraylist的原理

- 数组实现的List
- 当增加数据的时候，如果ArrayList的大小已经不满足需求时，那么就将数组变为原长度的1.5倍，之后的操作就是把老的数组拷到新的数组里面。
- remove函数：把后面的数据前移（利用 `System.arraycopy` ），最后一个元素置null

### 场景题：设计判断论文抄袭的系统

核心思想：以句子为单位，统计超过相似度阈值的句子数量。

### 堆排序的原理

直接把整数放入一个完全二叉树中（这里我们还是用一个一维数组来存储完全二叉树），然后通过直接的堆调整来完成排序。

**主要思想是将大根堆的堆顶取出，放到数组的最后一个位置，将最后一个位置原来的数放到堆顶，然后对堆顶做调整；**



### 抽象工厂和工厂方法模式的区别

![](https://upload-images.jianshu.io/upload_images/1873639-aa3431a5648c605d.png)

抽象工厂四要素：

- 客户端（client）
- 工厂（factory）
- 产品A（product A）
- 产品B（product B）

产品之间具有特定关系

工厂方法两要素：

- creator（创建者）
- product（产品）

**区别：**

- 抽象工程关键在于产品之间的抽象关系，所以至少要两个产品；工厂方法在于生成产品，不关注产品间的关系，所以可以只生成一个产品。（一般来说）
- 抽象工厂中客户端把产品的抽象关系理清楚，在最终使用的时候，一般使用客户端（和其接口），产品之间的关系是被封装固定的；而工厂方法是在最终使用的时候，使用产品本身（和其接口）。
- 工厂返回实体类实例，抽象工厂返回接口类型。
- 抽象工厂的工厂类就做一件事情生产产品。生产的产品给客户端使用，绝不给自己用。工厂方法生产产品，可以给系统用，可以给客户端用，也可以自己这个类使用。
- 若添加一个新的产品，前者是修改工厂，后者是创建新工厂

### 工厂模式的思想

如果用户 C 需要C 产品怎么办呢，这时，简单工厂模式 就需要修改工厂类，这就违反了开放封闭原则，开放是继承可以，封闭则是对类修改不行。

为了解决这个问题 出现了工厂方法模式。

为了不修改类，显然只有采用继承的方法，我可以有很多类来产生多个对象，但不能通过对一个类的修改来产生多个对象



### 哪里用到了工厂模式

valueOf、JDBC、NumberFormat

### Forward和redirect的区别

转发是服务器行为，重定向是客户端行为。

**区别**：

1. 从地址栏显示来说

forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址.

redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.

2. 从数据共享来说

forward:转发页面和转发到的页面可以共享request里面的数据.
redirect:不能共享数据.

3. 从运用地方来说

forward:一般用于用户登陆的时候,根据角色转发到相应的模块.
redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等

4. 从效率来说

forward:高.
redirect:低.



### Synchronize关键字为什么jdk1.5后效率提高了

sync实现原理：在语句块前后插入 monitorenter 和 monitorexit 指令。

**适应性自旋（Adaptive Spinning）** : 简单来说就是线程如果自旋成功（获取到锁）了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少。

**锁粗化（Lock Coarsening）：**锁粗化的概念应该比较好理解，就是将多次连接在一起的加锁、解锁操作合并为一次，将多个连续的锁扩展成一个范围更大的锁。

**锁消除（Lock Elimination）：**锁消除即删除不必要的加锁操作。根据代码逃逸技术，如果判断到一段代码中，堆上的数据不会逃逸出当前线程，那么可以认为这段代码是线程安全的，不必要加锁。

| 锁       | 优点                                                         | 缺点                                             | 适用场景                             |
| -------- | ------------------------------------------------------------ | ------------------------------------------------ | ------------------------------------ |
| 偏向锁   | 加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗。 | 适用于只有一个线程访问同步块场景。   |
| 轻量级锁 | 竞争的线程不会阻塞，提高了程序的响应速度。                   | 如果始终得不到锁竞争的线程使用自旋会消耗CPU。    | 追求响应时间。同步块执行速度非常快。 |
| 重量级锁 | 线程竞争不使用自旋，不会消耗CPU。                            | 线程阻塞，响应时间缓慢。                         | 追求吞吐量。同步块执行速度较长。     |

### 线程池的使用时的注意事项

线程池主要参数：

- corePoolSize

> 核心线程数，核心线程会一直存活，即使没有任务需要处理。当线程数小于核心线程数时，即使现有的线程空闲，线程池也会优先创建新线程来处理任务，而不是直接交给现有的线程处理。
>
> 核心线程在allowCoreThreadTimeout被设置为true时会超时退出，默认情况下不会退出。

- maxPoolSize

> 当线程数大于或等于核心线程，且任务队列已满时，线程池会创建新的线程，直到线程数量达到maxPoolSize。如果线程数已等于maxPoolSize，且任务队列已满，则已超出线程池的处理能力，线程池会拒绝处理任务而抛出异常。

- keepAliveTime

> 当线程空闲时间达到keepAliveTime，该线程会退出，直到线程数量等于corePoolSize。如果allowCoreThreadTimeout设置为true，则所有线程均会退出直到线程数量为0。

- allowCoreThreadTimeout

> 是否允许核心线程空闲退出，默认值为false。

- queueCapacity

> 任务队列容量。从maxPoolSize的描述上可以看出，任务队列的容量会影响到线程的变化，因此任务队列的长度也需要恰当的设置。



参数的设置跟系统的负载有直接的关系，下面为**系统负载**的相关参数：

- tasks，每秒需要处理的最大任务数量
- tasktime，处理每任务所需要的时间
- responsetime，系统允许任务最大的响应时间，比如每个任务的响应时间不得超过2秒。

参数设置

- 默认值
- - corePoolSize=1
  - queueCapacity=Integer.MAX_VALUE
  - maxPoolSize=Integer.MAX_VALUE
  - keepAliveTime=60s
  - allowCoreThreadTimeout=false
  - rejectedExecutionHandler=AbortPolicy()
- 如何来设置
- - 需要根据几个值来决定
  - - tasks ：每秒的任务数，假设为500~1000
    - taskcost：每个任务花费时间，假设为0.1s
    - responsetime：系统允许容忍的最大响应时间，假设为1s
  - 做几个计算
  - - corePoolSize = 每秒需要多少个任务处理？ 
    - - threadcount = tasks/(1/taskcost) =tasks*taskcout =  (500~1000)*0.1 = 50~100 个线程。corePoolSize设置应该大于50
      - 根据8020原则，如果80%的每秒任务数小于800，那么corePoolSize设置为80即可
    - queueCapacity = (coreSizePool/taskcost)*responsetime
    - - 计算可得 queueCapacity = 80/0.1*1 = 80。意思是队列里的线程可以等待1s，超过了的需要新开线程来执行
      - 切记不能设置为Integer.MAX_VALUE，这样队列会很大，线程数只会保持在corePoolSize大小，当任务陡增时，不能新开线程来执行，响应时间会随之陡增。
    - maxPoolSize = (max(tasks)- queueCapacity)/(1/taskcost)
    - - 计算可得 maxPoolSize = (1000-80)/10 = 92
      - （最大任务数-队列容量）/每个线程每秒处理能力 = 最大线程数
    - rejectedExecutionHandler：根据具体情况来决定，任务不重要可丢弃，任务重要则要利用一些缓冲机制来处理
    - keepAliveTime和allowCoreThreadTimeout采用默认通常能满足
- 以上都是理想值，实际情况下要根据机器性能来决定。如果在未达到最大线程数的情况机器cpu load已经满了，则需要通过升级硬件（呵呵）和优化代码，降低taskcost来处理。

（1） 线程池的大小。 多线程应用并非线程越多越好， 需要根据系统运行的软硬件环境以及应用本身的特点决定线程池的大小。 一般来说， 如果代码结构合理的话， 线程数目与 CPU数量相适合即可。 如果线程运行时可能出现阻塞现象， 可相应增加池的大小； 如有必要可采用自适应算法来动态调整线程池的大小， 以提高 CPU 的有效利用率和系统的整体性能。

（2） 并发错误。 多线程应用要特别注意并发错误， 要从逻辑上保证程序的正确性， 注意避免死锁现象的发生。

（3） 线程泄漏。 这是线程池应用中一个严重的问题， 当任务执行完毕而线程没能返回池中就会发生线程泄漏现象。

### Spring中autowire和resourse关键字的区别

- @Autowired是默认**按照类型装配**的 ，Spring 注解


- @Resource默认是**按照名称装配**的 ，JDK 注解



### 讲一下线程状态转移图

![](https://upload-images.jianshu.io/upload_images/6309329-11a280fa94f78adb.png)

### 消息队列了解么



12， 分布式了解么



### HTTPS 握手过程

1、**ClientHello** ：客户端首先会**将自己支持的加密算法**，打个包告诉服务器端。
2、**ServerHello** ：服务器端从客户端发来的加密算法中，选出一组加密算法和HASH算法（注，HASH也属于加密），并将自己的**身份信息以证书的形式发回给客户端**。而证书中包含了网站的地址，加密用的公钥，以及证书的颁发机构等；
  这里有提到公钥的概念是故事中没有的。我们常见的加密算法一般是一些对称的算法，如凯撒加密；对称算法即加密用的密钥和解密用的密钥是一个。如故事中的密钥是4。还有一种加密解密算法称之为非对称算法。这种算法加密用的密钥（公钥）和解密用的密钥（私钥）是两个不同的密钥；通过公钥加密的内容一定要使用私钥才能够解密。
  这里，服务器就将自己用来加密用的公钥一同发还给客户端，而私钥则服务器保存着，用户解密客户端加密过后的内容。

3、**Verification** ：客户端收到了服务器发来的数据包后，会做这么几件事情：
 1）验证一下证书是否合法。一般来说，证书是用来标示一个站点是否合法的标志。如果说该证书由权威的第三方颁发和签名的，则说明证书合法。
 2）如果证书合法，或者客户端接受和信任了不合法的证书，则**客户端就会随机产生一串序列号，使用服务器发来的公钥进行加密。**这时候，一条返回的消息就基本就绪。
 3）最后**使用服务器挑选的HASH算法，将刚才的消息使用刚才的随机数进行加密，生成相应的消息校验值，与刚才的消息一同发还给服务器。**

4、服务器接受到客户端发来的消息后，会做这么几件事情：
 1）使用私钥解密上面第2）中公钥加密的消息，得到客户端产生的随机序列号。
 2）**使用该随机序列号，对该消息进行加密，验证的到的校验值是否与客户端发来的一致**。如果一致则说明消息未被篡改，可以信任。
 3）最后，使用该随机序列号，加上之前第2步中选择的加密算法，**加密一段握手消息，发还给客户端。同时HASH值也带上。**

5、客户端收到服务器端的消息后，接着做这么几件事情：
 1）**计算HASH值是否与发回的消息一致**
 2）检查消息是否为握手消息

6、握手结束后，客户端和服务器端使用握手阶段产生的随机数以及**挑选出来的算法进行对称加解密的传输。**



简而言之：

1. 客户端发送支持的加密算法
2. 服务端返回选择的加密算法、证书（包含公钥）
3. 客户端验证证书，如不合法则警告用户
4. 若证书合法，客户端将生成一个随机数作为密钥，使用公钥将此密钥加密，并发给服务端
5. 服务端收到信息后，使用私钥解密出加密算法的密钥
6. 双方开始使用选择的加密算法与随机数来进行加解密传输

省略了hash算法生成随机数摘要的部分



总结一下就是：

（1） 客户端向服务器端索要并验证公钥。

（2） 双方协商生成"对话密钥"。

（3） 双方采用"对话密钥"进行加密通信。

前两步是握手过程。



### Redis持久化

[Redis](http://redis.io/)有两种持久化的方式：快照（`RDB`文件）和追加式文件（`AOF`文件）：

- RDB持久化方式会在一个特定的间隔保存那个时间点的一个数据快照。
- AOF持久化方式则会记录每一个服务器收到的写操作。在服务启动时，这些记录的操作会逐条执行从而重建出原来的数据。写操作命令记录的格式跟Redis协议一致，以追加的方式进行保存。
- Redis的持久化是可以禁用的，就是说你可以让数据的生命周期只存在于服务器的运行时间里。
- 两种方式的持久化是可以同时存在的，但是当Redis重启时，AOF文件会被优先用于重建数据。



### AOP 实现

AspectJ 是静态代理的增强，所谓的静态代理就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强。

Spring AOP使用的**动态代理**，所谓的动态代理就是说AOP框架不会去修改字节码，而是在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。

Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理。JDK动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK动态代理的核心是`InvocationHandler`接口和`Proxy`类。

**JDK的动态代理依靠接口实现，入参必须有被代理类的接口**，也就是`xxxImpl.getClass().getInterfaces()`,如果有些类并没有实现接口，则不能使用JDK代理

cglib是针对类来实现代理的，他的原理是对指定的目标类**生成一个子类，并覆盖其中方法实现增强**，但因为采用的是继承，所以不能对final修饰的类进行代理。（cglib也可以与Java动态代理一样面向接口，因为本质是继承。）

简而言之：

- JDK 代理的是接口，原理是代理对象和目标对象实现了相同的接口，目标对象作为代理对象的一个属性；
- CGLIB 代理的是类，原理是对指定的目标类**生成一个子类，并覆盖其中方法实现增强**；

### RabbitMQ

- exchange： producer只能将消息发送给exchange。而exchange负责将消息发送到queues。Exchange必须准确的知道怎么处理它接受到的消息，是被发送到一个特定的queue还是许多quenes,还是被抛弃，这些规则则是通过exchange type来定义。主要的type有direct,topic,headers,fanout。具体针对不同的场景使用不同的type。
- queue: 消息队列，消息的载体。接收来自exchange的消息，然后再由consumer取出。exchange和queue是可以一对多的，它们通过routingKey来绑定。
- Producer:生产者，消息的来源,消息必须发送给exchange。而不是直接给queue
- Consumer:消费者，直接从queue中获取消息进行消费，而不是从exchange。

从以上可以看出Rabbitmq工作原理大致就是producer把一条消息发送给exchange。rabbitMQ根据routingKey负责将消息从exchange发送到对应绑定的queue中去，这是由rabbitMQ负责做的。而consumer只需从queue获取消息即可。

- 简单发送模型

  在rabbit MQ里消息永远不能被直接发送到queue。这里我们通过提供一个空字符串来使用默认的exchange。这个exchange是特殊的，它可以根据routingKey把消息发送给指定的queue。

- 工作队列模型

  一个生产者（Boss）向队列发消息（任务），多个消费者（worker）从队列接受消息（任务）

  1. 一条消息只会被一个消费者接收；
  2. 消息是平均分配给消费者的；
  3. 消费者只有在处理完某条消息后，才会收到下一条消息。

  事实上，**RabbitMQ**会循环地（一个接一个地）发送消息给消费者，这种分配消息的方式被称为**round-robin（轮询）**。

- 广播订阅模型

  让所有的消费者都能够接收到每一条消息。显然，`fanout`类型的交换机更符合我们当前的需求。为此，先创建一个 `fanout` 类型的交换机。

- RPC 应用模型



### 长连接

在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。

HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。



### Memcached 与 Redis 区别

- **数据类型支持不同** ：Memcached 仅支持简单的 key-value 数据记录，而 Redis 除此之外，还提供list,set,zset,hash等数据结构的存储
- **内存管理机制不同** ：Memcached默认使用Slab Allocation机制管理内存，其主要思想是按照预先规定的大小，将分配的内存分割成特定长度的块以存储相应长度的key-value数据记录，以完全解决内存碎片问题。Redis为了方便内存的管理，在分配一块内存之后，会将这块内存的大小存入内存块的头部。
- **数据持久化支持** ：memcached不支持内存数据的持久化操作，所有的数据都以in-memory的形式存储。redis支持持久化操作。redis提供了两种不同的持久化方法来讲数据存储到硬盘里面，一种是快照（snapshotting)，它可以将存在于某一时刻的所有数据都写入硬盘里面。另一种方法叫只追加文件（append-only file， AOF),它会在执行写命令时，将被执行的写命令复制到硬盘里面。
- **集群管理的不同** ：Memcached本身并不支持分布式，因此只能在客户端通过像一致性哈希这样的分布式算法来实现Memcached的分布式存储。最新版本的Redis已经支持了分布式存储功能。Redis Cluster是一个实现了分布式且允许单点故障的Redis高级版本，它没有中心节点，具有线性可伸缩的功能。

### Hibernate和mybatis的区别

**Mybatis**：小巧、方便、高效、简单、直接、半自动化

**Hibernate**：强大、方便、高效、复杂、间接、全自动化



**（1）hibernate是全自动，而mybatis是半自动**

hibernate完全可以通过对象关系模型实现对数据库的操作，拥有完整的JavaBean对象与数据库的映射结构来自动生成sql。而mybatis仅有基本的字段映射，对象数据以及对象实际关系仍然需要通过手写sql来实现和管理。

**（2）hibernate数据库移植性远大于mybatis**

hibernate通过它强大的映射结构和hql语言，大大降低了对象与数据库（Oracle、MySQL等）的耦合性，而mybatis由于需要手写sql，因此与数据库的耦合性直接取决于程序员写sql的方法，如果sql不具通用性而用了很多某数据库特性的sql语句的话，移植性也会随之降低很多，成本很高。

**（3）hibernate拥有完整的日志系统，mybatis则欠缺一些**

hibernate日志系统非常健全，涉及广泛，包括：sql记录、关系异常、优化警告、缓存提示、脏数据警告等；而mybatis则除了基本记录功能外，功能薄弱很多。

**（4）mybatis相比hibernate需要关心很多细节**

hibernate配置要比mybatis复杂的多，学习成本也比mybatis高。但也正因为mybatis使用简单，才导致它要比hibernate关心很多技术细节。mybatis由于不用考虑很多细节，开发模式上与传统jdbc区别很小，因此很容易上手并开发项目，但忽略细节会导致项目前期bug较多，因而开发出相对稳定的软件很慢，而开发出软件却很快。hibernate则正好与之相反。但是如果使用hibernate很熟练的话，实际上开发效率丝毫不差于甚至超越mybatis。

**（5）sql直接优化上，mybatis要比hibernate方便很多**

由于mybatis的sql都是写在xml里，因此优化sql比hibernate方便很多。而hibernate的sql很多都是自动生成的，无法直接维护sql；虽有hql，但功能还是不及sql强大，见到报表等变态需求时，hql也歇菜，也就是说hql是有局限的；hibernate虽然也支持原生sql，但开发模式上却与orm不同，需要转换思维，因此使用上不是非常方便。总之写sql的灵活度上hibernate不及mybatis。

**（6）缓存机制上，hibernate要比mybatis更好一些**

MyBatis的二级缓存配置都是在每个具体的表-对象映射中进行详细配置，这样针对不同的表可以自定义不同的缓存机制。并且Mybatis可以在命名空间中共享相同的缓存配置和实例，通过Cache-ref来实现。

而Hibernate对查询对象有着良好的管理机制，用户无需关心SQL。所以在使用二级缓存时如果出现脏数据，系统会报出错误并提示。



### Linux命令

- 查找大文件

  ```bash
  # 方法1
  $ find . -type f -size +800M

  # 方法2
  $ du -h . | sort -nr | head -10
  ```

  ​

- 查看系统日志：tail、less、cat、head



### Java 接口与抽象类的区别

接口是对动作的抽象，而抽象类是对根源的抽象。

| **参数**           | **抽象类**                                                   | **接口**                                                     |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **默认的方法实现** | 它可以有默认的方法实现                                       | 接口完全是抽象的。它根本不存在方法的实现                     |
| 实现               | 子类使用**extends**关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。 | 子类使用关键字**implements**来实现接口。它需要提供接口中所有声明的方法的实现 |
| **构造器**         | 抽象类可以有构造器                                           | 接口不能有构造器                                             |
| 与正常Java类的区别 | 除了你不能实例化抽象类之外，它和普通Java类没有任何区别       | 接口是完全不同的类型                                         |
| 访问修饰符         | 抽象方法可以有**public**、**protected**和**default**这些修饰符 | 接口方法默认修饰符是**public**。你不可以使用其它修饰符。     |
| main方法           | **抽象方法可以有main方法**并且我们可以运行它                 | 接口没有main方法，因此我们不能运行它。                       |
| 多继承             | 抽象方法可以继承一个类和实现多个接口                         | 接口只可以继承一个或多个其它接口                             |
| 速度               | 它比接口速度要快                                             | 接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。   |
| 添加新方法         | 如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。 | 如果你往接口中添加方法，那么你必须改变实现该接口的类。       |

### GC 机制问题详谈

三个问题：

1. 哪些内存需要回收？what -> 可达性算法（对象），3个条件（类）
2. 什么时候回收？when -> 分代回收（Young -> Old -> 永久代）
3. 怎么回收？how -> 安全点/安全区

#### 问题1：回收哪些内存？

可达性算法（GC Roots），当一个对象到 GC Root 对象没有任何引用链/不可达时，判定为可回收对象。

GC Roots 对象选取（stack、static、final）：

- 栈引用对象：虚拟机栈、Native 栈 中引用的对象（可通过查询栈的本地变量表获知）
- static 引用对象：类静态属性引用的对象
- final 引用对象：方法区常量引用的对象

对于方法区（永久代）中的无用类、废弃常量，用3个条件来判断该类是否 “无用”：

- 该类所有实例已被回收
- 该类加载器已被回收
- 该类对应的 java.lang.Class 对象没有被引用（即无反射访问）



#### 问题2：什么时候回收？

分代收集算法，新生代、老年代、持久代。

新生代 Eden 区满时触发 Minor GC，



#### 问题3：安全点与安全区



### 垃圾收集器问题

- Serial 收集器：单线程收集，分新生代、老年代版本，stop the world
- ParNew 收集器：多线程版 ParNew，分新生代、老年代版本
- Parallel Scavenge 收集器：新生代收集器，关注吞吐量（即gc时间占比越小越好）
- CMS 收集器：老年代收集器，使用标记-清理（而非标记-整理）算法，关注停顿时间（即gc过程中尽量减少系统停顿时间），易产生空间碎片
- G1 收集器：面向服务端，同时管理新生代、老年代，整体使用标记-整理（局部看来是复制算法），关注停顿时间，但是停顿时间可预测。



### 协程与线程

**协程是一种用户态的轻量级线程，**协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

整个流程无锁，由一个线程执行，produce和consumer协作完成任务，所以称为“协程”，而非线程的抢占式多任务。

协程在用户态进行显式的任务调度，可以把异步操作转换成同步操作

### 守护进程和僵尸进程，孤儿进程

我们知道在unix/linux中，正常情况下，子进程是通过父进程创建的，子进程在创建新的进程。子进程的结束和父进程的运行是一个异步过程，即父进程永远无法预测子进程 到底什么时候结束。 当一个 进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。

- 孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。**孤儿进程不会对系统造成危害**
- 僵尸进程（状态栏为defunct）：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。（系统调用 exit，它的作用是将一个正常的进程变成一个僵尸进程，并不能将其完全销毁）
- Linux Daemon（守护进程）：是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。它不需要用户输入就能运行而且提供某种服务，不是对整个系统就是对某个用户程序提供服务。Linux系统的大多数服务器就是通过守护进程实现的。常见的守护进程包括系统日志进程syslogd、 web服务器httpd、邮件服务器sendmail和数据库服务器mysqld等。

### 如何消灭系统中大量的僵死进程时

把产生大量僵死进程的那个元凶枪毙掉（也就是通过kill发送SIGTERM或者SIGKILL信号啦）。

```bash
ps -ef | grep defunct_process_pid
```

枪毙了元凶进程之后，它产生的**僵死进程就变成了孤儿进程**，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源，这样，这些已经僵死的孤儿进程 就能瞑目而去了。

 一般，为了**防止产生僵尸进程**，在fork子进程之后我们都要wait它们；同时，当子进程退出的时候，内核都会给父进程一个SIGCHLD信号，所以我们可以建立一个捕获SIGCHLD信号的信号处理函数，在函数体中调用wait（或waitpid），就可以清理退出的子进程以达到防止僵尸进程的目的。

### 硬链接与软链接的联系与区别

ln命令产生硬链接，ln命令加上- s选项，则建立软链接。

文件都有文件名与数据，这在 Linux 上被分成两个部分：用户数据 (user data) 与元数据 (metadata)。

- 用户数据，即文件数据块 (data block)，数据块是记录文件真实内容的地方；
- 而元数据则是文件的附加属性，如文件大小、创建时间、所有者等信息。

在 Linux 中，元数据中的 inode 号（inode 是文件元数据的一部分但其并不包含文件名，inode 号即索引节点号）才是文件的唯一标识而非文件名。

**若一个 inode 号对应多个文件名，则称这些文件为硬链接。换言之，硬链接就是同一个文件使用了多个别名**（hard link 就是 file 的一个别名，他们有共同的 inode）。

由于硬链接是有着相同 inode 号仅文件名不同的文件，因此硬链接存在以下几点特性：

- 文件有相同的 inode 及 data block；
- 只能对已存在的文件进行创建；
- 不能交叉文件系统进行硬链接的创建；
- 不能对目录进行创建，只可对文件创建；
- **删除一个硬链接文件并不影响其他有相同 inode 号的文件**。

**软链接与硬链接不同，若文件用户数据块中存放的内容是另一文件的路径名的指向，则该文件就是软连接**。软链接就是一个普通文件，只是数据块内容有点特殊，软链接文件有类似于Windows的快捷方式。。软链接有着自己的 inode 号以及用户数据块.

- 软链接有自己的文件属性及权限等；
- 可对不存在的文件或目录创建软链接；
- 软链接可交叉文件系统；
- 软链接可对文件或目录创建；
- **创建软链接时，链接计数 i_nlink 不会增加**；
- **删除软链接并不影响被指向的文件**，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）。

### Inode 是什么

**inode** 是指在许多“类Unix文件系统”中的一种数据结构。每个inode保存了文件系统中的一个文件系统对象（包括文件、目录、设备文件、socket、管道, 等等）的元信息数据，但不包括数据内容或者文件名



### 强类型和弱类型，静态类型动态类型是什么？

- 强类型：偏向于不容忍隐式类型转换。譬如说haskell的int就不能变成double
- 弱类型：偏向于容忍隐式类型转换。譬如说C语言的int可以变成double
- 静态类型：编译的时候就知道每一个变量的类型，因为类型错误而不能做的事情是语法错误。
- 动态类型：编译的时候不知道每一个变量的类型，因为类型错误而不能做的事情是运行时错误。譬如说你不能对一个数字a写a[10]当数组用。



### http1.0和1.1有什么区别

- 长连接：HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接。
- 带宽优化：
  - HTTP/1.1加入了一个新的状态码100（Continue），客户端事先发送一个只带头域的请求，拒绝发送401; 接受则发送100,客户端就可以继续发送带实体的完整请求了
  - 断点续传（支持传送内容的一部分。这样当客户端已经有一部分的资源后，只需要跟服务器请求另外的部分资源即可）
- HOST域：web server上的多个虚拟站点可以共享同一个ip和端口。
- 缓存处理：HTTP1.1引入了更多的缓存控制策略
- 新增了24个错误状态响应码：如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除



### HTTP1.1 HTTP 2.0主要区别

- 多路复用（NIO）：做到同一个连接并发处理多个请求，不需要额外建立TCP
- 数据压缩：HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。
- 服务器推送：请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端



### TCP粘包、拆包（半包、断包）

- 粘包：多个混一起
- 拆包：一个分多个

造成原因：

1. 要发送的数据**大于TCP发送缓冲区剩余空间大小**，发生拆包；
2. 待发送数据大于MSS（最大报文长度），TCP在传输前进行拆包；
3. 要发送的数据**小于TCP发送缓冲区的大小**，TCP将多次写入缓冲区的数据一次发送出去，造成粘包;
4. 接收方没能及时地接收缓冲区的数据，造成粘包;

过大拆包，过小粘包。

如何处理：

1. **使用带消息头的协议（客户端）**、消息头存储消息开始标识及消息长度信息，服务端获取消息头的时候解析出消息长度，然后向后读取该长度的内容。
2. **设置定长消息（服务端-客户端共同实现）**，服务端每次读取既定长度的内容作为一条完整消息。
3. **设置消息边界（客户端）**，服务端从网络流中按消息编辑分离出消息内容。



### Tcp的time_wait

客户端主动关闭连接时，会发送最后一个ack后，然后会进入TIME_WAIT状态，再停留2个MSL时间(后有MSL的解释)，进入CLOSED状态。

TCP/IP协议就是这样设计的，是不可避免的。主要有两个原因:

1. 可靠地实现TCP全双工连接的终止，防止最后一个 ACK 丢失后无法再次响应服务端重传的 FIN；

四次握手过程中，最终的ACK是由主动关闭连接的一端发出的，如果这个ACK丢失，对方将重发出最终的 FIN，因此A端必须维护状态信息（TIME_WAIT）允许它重发最终的ACK。如果A端不维持TIME_WAIT状态，而是处于CLOSED 状态，那么A端将响应RST错误（关闭连接异常）

2. 保证当成功建立一个新TCP连接的时候，来自旧连接重复分组已经在网络中消逝。



- **MSL**：指的是报文段的最大生存时间，如果报文段在网络活动了MSL时间，还没有被接收，那么会被丢弃。关于MSL的大小，RFC 793协议中给出的建议是两分钟，不过实际上不同的操作系统可能有不同的设置，以**Linux为例，通常是半分钟，两倍的MSL就是一分钟，也就是60秒**，并且这个数值是硬编码在内核中的，也就是说除非你重新编译内核，否则没法修改它。



### Cookie 属性选项

`cookie` 选项包括：`expires`、`domain`、`path`、`secure`、`HttpOnly`。

示例：

```json
"key=name; expires=Thu, 25 Feb 2016 04:18:00 GMT; domain=ppsc.sankuai.com; path=/; secure; HttpOnly"
```

- **expires**：cookie 失效日期，**默认有效期为**`session`，即会话`cookie`。这种`cookie`在浏览器关闭后就没有了。在 http/1.1 协议中，expires已经由 max-age 选项代替，两者的作用都是限制cookie 的有效时间。expires的值是一个时间点（cookie失效时刻= expires），而 max-age 的值是一个以秒为单位时间段（cookie失效时刻= 创建时刻+ max-age）。**max-age 的默认值是 -1**（即有效期为 session )；
- **domain 和 path**：domain是域名，path是路径，两者加起来就构成了 URL，domain和path一起来限制 cookie 能被哪些 URL 访问。2个选项共同决定了cookie何时被浏览器自动添加到请求头部中发送出去。如果没有设置这两个选项，则会使用默认值。**domain的默认值为设置该cookie的网页所在的域名，path默认值为设置该cookie的网页所在的目录**。
- **secure** ：当请求是HTTPS或者其他安全协议时，包含 secure 选项的 cookie 才能被发送至服务器。**默认无**
- **httpOnly** ：设置cookie是否能通过 js 去访问。**默认情况下，cookie不会带httpOnly选项**



Cookie 可以通过服务器的 response header 中 `Set-Cookie` 字段来设置，如：

![](https://sfault-image.b0.upaiyun.com/237/110/2371104766-56dd2fc2ba7ae)



### MySQL之char、varchar和text

- char（n）和varchar（n）中括号中n代表**字符**的个数，并不代表**字节**个数，所以当使用了中文的时候(UTF8)意味着可以插入n个中文，但是实际会占用n * 3个字节（GBK为n * 2）
- char和varchar最大的区别就在于char不管实际value都会占用n个**字符**的空间，而varchar只会占用实际字符应该占用的空间+1，并且实际空间+1<=n。
- 超过char和varchar的n设置后，字符串会被截断
- char的上限为255字节，varchar的上限65535字节（最大可用为65532，长度占用1~3个字节），text的上限为65535字节（全可用）
- char在存储的时候会截断尾部的空格，varchar和text不会。

从官方文档中我们可以得知当varchar大于某些数值的时候，其会自动转换为text，大概规则如下：

- 大于varchar（255）变为 tinytext
- 大于varchar（500）变为 text
- 大于varchar（20000）变为 mediumtext

**当超过255的长度之后，使用varchar和text没有本质区别**







### 事件委托和事件冒泡、捕获机制

- 事件冒泡

微软提出了名为事件冒泡(event bubbling)的事件流。事件冒泡可以形象地比喻为把一颗石头投入水中，泡泡会一直从水底冒出水面。也就是说，事件会从最内层的元素开始发生，一直向上传播，直到document对象。

因此在事件冒泡的概念下在p元素上**发生click事件**的顺序应该是p -> div -> body -> html -> document

- 事件捕获

网景提出另一种事件流名为事件捕获(event capturing)。与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素。

因此在事件捕获的概念下在p元素上**发生click事件**的顺序应该是 document -> html -> body -> div -> p

- 事件委托/事件代理：简言之，在父类上绑定一个事件，然后通过回调函数的参数获得当前点击的是哪一个元素，相当于把事件绑定在子元素身上。主要通过**事件冒泡机制**来实现




### select、poll、epoll详解

select，poll，epoll都是IO多路复用的机制。

多路复用是通过一种机制，一个进程可以监视多个描述符（fd），一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。



- select和poll缺点：（1）每次调用select都需要将fd集合从用户态拷贝到内核态（2）**线性扫描/轮询方式：**每一次调用select都需要在内核中遍历所有的fd（3）select支持的文件描述符太小，默认1024，poll没有限制  
- epoll：使用红黑树来存储fd，同时每一次通过epoll_ctl来将fd加入内核中，同时通过双向列表来移除已经触发某一个事件的fd

![](https://pic1.zhimg.com/v2-e6a869884585625dfc7eace1b90c3024_r.jpg)



#### epoll

epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。

epoll对文件描述符的操作有两种模式：LT(level trigger，水平触发)和ET(edge trigger)。

**水平触发：**默认工作模式，即当epoll_wait检测到某描述符事件就绪并通知应用程序时，应用程序可以不立即处理该事件；下次调用epoll_wait时，会再次通知此事件。

**边缘触发：**当epoll_wait检测到某描述符事件就绪并通知应用程序时，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次通知此事件。

epoll 提供了 3 个函数接口：

1. **epoll_create**函数创建一个epoll句柄，参数size表明内核要监听的描述符数量。调用成功时返回一个epoll句柄描述符，失败时返回-1。

2. **epoll_ctl**函数注册要监听的事件类型。


3. **epoll_wait**函数等待事件的就绪，成功时返回就绪的事件数目，调用失败时返回 -1，等待超时返回 0。





### 海量数据算法

注意 $2^{32}=4G$ （40亿），这个规模的数据不能放入内存来搞

#### 从海量数据中找出现频次最高/top10的数

Solve：分治 + Hash

- 把数据分为 1000+ 个小文件（写入统计频次即可），使用 Hash（num）% 1000，确保相同数据出现在同一文件中
- 找出每个文件出现频次最高的数（可以使用 hashmap）
- 排序得到答案

若重复度极高，则可以使用hashmap来维护频次，再使用一个堆来维护.

#### 从海量数据中找到最大/小（最优先）的 k 个数

Solve：维护一个大小为 k 的堆/优先队列即可

#### 为海量数据排序

Solve：归并排序-外排序

先划分文件（文件大小小于内存），再归并结果写入文件（归并过程不需要额外空间，移动指针即可）

#### 为海量小范围数据排序

Solve：位图排序-桶排序（适用于数据空间在缩小 32 倍后能放入内存的情况，如所有qq号，所有9位数，不适用百亿以上的空间）

理论上必须去重，如果不去重则需要保证均匀分布

1. 计算需要内存，全部初始化为0 
2. 读取文件中的数据，将数据对应的bit置1
3. 遍历整个bit，将bit为1的依次存入文件

#### 在海量数据中找出不重复的数据

Solve：2-bitmap（每个数分配2bit，00为未出现，01为出现一次，10为多次，11无意义）

扫描一次，对于扫描到的数字，00变01，01变10，10保持不变。

最后输出10状态的数即可。

#### 多次判断一项数据是否在海量数据中出现过

关键在于建立一个快速查询的数据结构，建立时间复杂度要低（因此不能排序）

Solve：建立位图法/依次按最高位折半查找

#### 从海量数据中找出中位数/第k大数

Solve：多次划分，统计落到不同区域中数的个数，精确定位

#### 求两个海量数据集合的交集

- 允许少量错误：bloom 过滤器
- 不允许错误：分别通过hash%划分为多个小文件（如：a1, a2,..., a100; b1, b2,..., b100），两个模除值相等的小文件做比较（如：a1和b1）



### 尾调用与尾递归

- 尾调用：某个函数的最后一步是调用另一个函数。
- 尾递归：尾调用自身



### 缓存一致性

过期策略：expire

MESI是四种缓存段状态的首字母缩写，任何多核系统中的缓存段都处于这四种状态之一。我将以相反的顺序逐个讲解，因为这个顺序更合理：

- 失效（Invalid）缓存段，要么已经不在缓存中，要么它的内容已经过时。为了达到缓存的目的，这种状态的段将会被忽略。一旦缓存段被标记为失效，那效果就等同于它从来没被加载到缓存中。
- 共享（Shared）缓存段，它是和主内存内容保持一致的一份拷贝，在这种状态下的缓存段只能被读取，不能被写入。多组缓存可以同时拥有针对同一内存地址的共享缓存段，这就是名称的由来。
- 独占（Exclusive）缓存段，和S状态一样，也是和主内存内容保持一致的一份拷贝。区别在于，如果一个处理器持有了某个E状态的缓存段，那其他处理器就不能同时持有它，所以叫“独占”。这意味着，如果其他处理器原本也持有同一缓存段，那么它会马上变成“失效”状态。
- 已修改（Modified）缓存段，属于脏段，它们已经被所属的处理器修改了。如果一个段处于已修改状态，那么它在其他处理器缓存中的拷贝马上会变成失效状态，这个规律和E状态一样。此外，已修改缓存段如果被丢弃或标记为失效，那么先要把它的内容回写到内存中——这和回写模式下常规的脏段处理方式一样。

### **二者的不同之处**

*Exception：*
1．可以是可被控制(checked) 或不可控制的(unchecked) 
2．表示一个由程序员导致的错误 
3．应该在应用程序级被处理

 

*Error：*
1．总是不可控制的(unchecked) 
2．经常用来用于表示系统错误或低层资源的错误 
3．如何可能的话，应该在系统级被捕捉

 

### Shell 编程

1. shell特殊参数 ?

   ```shell
   #!/bin/bash

   echo $0 # 文件名
   echo $1 # 参数1
   echo $2 # 参数2
   echo $# # 参数个数
   echo $? # 运行一段shell后的结束代码（正常结束一般是0）
   echo $$ # 运行这段 shell 脚本的 sh 进程 pid

   sleep 5 & 
   echo $! # 最近运行的后台异步程序 pid，比如上一条 sleep 命令（pid为32131）

   echo $- # 显示shell的当前选项
   set -a  # 开启自动标记选项
   echo $-

   echo $@ # 所有参数列表，输出一个字符串
   echo $* # 所有参数列表，输出多个字符串（即split后）

   ```

   ```bash
   $ ./my.sh arg1 arg2
   my.sh
   arg1
   arg2
   2
   0
   32130
   32131
   hB
   ahB
   arg1 arg2
   arg1 arg2
   ```

   ​

2. 获取文件指定内容

   ```shell
   head -10 # 前10行
   tail -10 # 尾10行
   head -10 | awk '{print $1}' # 输出前10行的第1项
   head -10 | awk '{if ($1 == "FIND") print $2}' # 在前10行中，如果第一项为 “FIND”，则输出第二项
   ```

   ​

3. bash脚本调试：bash -xv xxx.sh 或 在bash文件中首行改为 `#!/bin/bash -xv`

4. 函数编写（和 JavaScript 比较像的写法）：

   ```bash
   #!/bin/bash

   function example() {
       echo "function 1 content."
   }

   echo "-----函数1开始执行-----"
   example
   echo "-----函数1执行完毕-----"

   function funWithReturn() {
       echo "Calc 1 + 2"
       one=1
       two=2
       return $(($one + $two)) # !双括号
   }

   echo "-----函数2开始执行-----"
   funWithReturn
   echo "1 + 2 = $?" # 调用$? 获得函数运行结果
   echo "-----函数2执行完毕-----"

   funWithParam(){
       echo "第一个参数为 $1 !"
       echo "第二个参数为 $2 !"
       echo "第十个参数为 $10 !"
       echo "第十个参数为 ${10} !"  # 当n>=10时，需要使用${n}来获取参数
       echo "第十一个参数为 ${11} !"
       echo "参数总数有 $# 个!"
       echo "作为一个字符串输出所有参数 $* !"
   }
   echo "-----函数3开始执行-----"
   funWithParam 1 2 3 4 5 6 7 8 9 34 73
   echo "-----函数3执行完毕-----" 

   ```

   ```
   -----函数1开始执行-----
   function 1 content.
   -----函数1执行完毕-----
   -----函数2开始执行-----
   Calc 1 + 2
   1 + 2 = 3
   -----函数2执行完毕-----
   -----函数3开始执行-----
   第一个参数为 1 !
   第二个参数为 2 !
   第十个参数为 10 !
   第十个参数为 34 !
   第十一个参数为 73 !
   参数总数有 11 个!
   作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !
   -----函数3执行完毕-----

   ```

   ​

5. Shell 字符串

   - 单引号字符串为原生字符串，一切照原样输出，变量无效，转义字符无效，字符串内不得出现单引号
   - 双引号字符串里可有变量，可有转义字符，可有变量
   - 反引号字符串会被解释为命令行，等同于 `$()` ，推荐后一种用法

6. ​
   ```

   ```



### Synchronized原理

在语句块前后插入 monitorenter 和 monitorexit 指令。
